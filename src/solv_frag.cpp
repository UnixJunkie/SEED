/*
*    This file is part of SEED.
*
*    Copyright (C) 2017, Caflisch Lab, University of Zurich
*
*    SEED is free software: you can redistribute it and/or modify
*    it under the terms of the GNU General Public License as published by
*    the Free Software Foundation, either version 3 of the License, or
*    (at your option) any later version.
*
*    SEED is distributed in the hope that it will be useful,
*    but WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*    GNU General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <time.h>
#include "nrutil.h"
#include "funct.h"
#include <iomanip> // added by clangini
#include <limits>  // added by clangini

void ElecFrag(int ReAtNu,double **ReCoor,double *RePaCh,
              double **RePaCh_Fr,double *ReRad,
              double *ReRad2,double *ReRadOut,double *ReRadOut2,
              double *ReEffRad_bound,
              struct point *surfpt_re,int *nsurf_re,
              int *pointsrf_re,double *ReSelfVol,int FrAtNu,double **RoSFCo,
              double **FrCoor,double *FrPaCh,double *FrRad,double *FrRad2,
              double *FrRadOut,double *FrRadOut2,
              double *FrEffRad_bound,
              double **Frdist2,double **dist2,
              double *FrMinC_orig,double *FrMaxC_orig,
              double *PFrSolvEn,int Nsurfpt_fr,struct point *surfpt_fr_orig,
              int *nsurf_fr,int *pointsrf_fr,struct point *surfpt_ex,
              double Tr[4],double U1[4][4],double U2[4][4],double WaMoRa,
              double GrSiSo,int NPtSphere,struct point Min,
              struct point Max,double *XGrid,double *YGrid,double *ZGrid,
              int NGridx,int NGridy,int NGridz,char ***GridMat,
              double ***DeltaPrDeso,
              double Kelec,double Ksolv,double UnitVol,double pi4,
              int nxminBS,int nyminBS,int nzminBS,int nxmaxBS,
              int nymaxBS,int nzmaxBS,double corr_scrint,
              double corr_fr_deso,double *PReDesoElec,
              double *PReFrIntElec,double *PFrDesoElec,double *ReSelfVol_corrB,
	            char *EmpCorrB, FILE * FPaOut)
/*########################################################################
Continuum Electrostatics: it calculates the rec and frag desolvation,
as well as the screened interaction. Slow and precise method
########################################################################*/

/*#######################################################################
int ReAtNu -------------- Tot # rec atoms
double **ReCoor ---------- Rec Coordinates
double *RePaCh ----------- Rec partial charges
double *RePaCh_Fr -------- Modified rec partial charges (for the charged residues
                          around the BS a unit charge is assigned to the atom
                          closest to the charge center
double *ReRad ----------- Rec charge radii (=vdW radii apart "enclosed" H)
double *ReRad2 ---------- (Rec charge radii)^2
double *ReRadOut -------- Rec charge radii + WaMoRa
double *ReRadOut2 ------- (Rec charge radii + WaMoRa)^2

==============================================================================
                  SAS1 is a SAS built to obtain the volume enclosed by the MS
                  SAS2 is a SAS built for a fast evaluation of the desolvation
                  SAS3 is a SAS built to estimate the surface hydrophobicity
==============================================================================

struct point *surfpt_re - Coor of points over rec SAS1
int *nsurf_re ----------- nsurf_re[n] = amount of SAS1 surface points
                          generated by rec atom n
int *pointsrf_re -------- pointsrf_re[n] = first rec SAS1 point (in the
                          list surfpt_re) that is generated by rec atom n
double **ReSelfVol ------ ReSelfVol[iat] = integral of 1/r^4 over the receptor
                          volume for atom iat
int FrAtNu -------------- Tot # frag atoms
double **RoSFCo ---------- Frag coordinates in the seeded conformation
double **FrCoor ---------- Frag coordinates in the original location
double *FrPaCh ----------- Frag partial charges
double *FrRad ----------- Frag charge radii (=vdW radii apart "enclosed" H)
double *FrRad2 ---------- (Frag charge radii)^2
double *FrRadOut -------- Frag charge radii + WaMoRa
double *FrRadOut2 ------- (Frag charge radii + WaMoRa)^2
double **Frdist2 --------- Squared interatomic frag distances
double **dist2 ----------- Squared interatomic rec-frag distances
double *FrMinC_orig ------ Min (along x,y,z) of FrCoor
double *FrMaxC_orig ------ Max (along x,y,z) of FrCoor
double *PFrSolvEn ------- Frag solvation energy
int Nsurfpt_fr ---------- Tot # of points over the frag SAS1
struct point *surfpt_fr_orig - Coor of points over frag SAS1 (obtained from
                               FrCoor coordinates)
int *nsurf_fr ----------- nsurf_fr[n] = amount of SAS1 surface points
                          generated by frag atom n
int *pointsrf_fr -------- pointsrf_fr[n] = first frag SAS1 point (in the
                          list surfpt_fr) that is generated by frag atom n
struct point *surfpt_ex - Coor of points over SAS1 generated by the frag and
                          by those rec atoms that are at a distance < 2*WaMoRa
                          from at least 1 frag atom
double Tr[4] ------------ Translation vector to superimpose the first atom of
                          FrCoor with the first of RoSFCo
double U1[4][4] --------- Rotation matrix around the axis passing by the 1st atom
                          of FrCoor and perpendicular to the plane formed by the
                          vector joining the 1st atom and the 2nd atom of FrCoor
                          and the vector joining the 1st atom and the 2nd atom of
                          RoSFCo. The rotation angle is such that it superimpose
                          the 2nd atom of RoSFCo with the 2nd atom of FrCoor
double U2[4][4] --------- Rotation matrix around the axis joining the 1st atom and
                          the 2nd atom of RoSFCo in order to superimpose
                          the 3rd atom of RoSFCo with the 3rd atom of FrCoor
double WaMoRa ----------- Radius of the water molecule
double GrSiSo ----------- Size of the 3D grid used for cont. electrostatics
double GrInSo ----------- Margin left along each dimension (positive and
                          negative) of the rec for building the 3D grid box
int NPtSphere ----------- Amount of points placed over each atom to generate
                          the SAS (built in order to obtain the volume
                          enclosed by the MS)
struct point Min -------- Min coor of the grid box
struct point Max -------- Max coor of the grid box
double *XGrid ----------- X coor of the grid points
double *YGrid ----------- Y coor of the grid points
double *ZGrid ----------- Z coor of the grid points
int  NGridx ------------- Tot # of grid points along x
int  NGridy ------------- Tot # of grid points along y
int  NGridz ------------- Tot # of grid points along z
char ***GridMat --------- Matrix telling if a grid point is occupied by the
                          rec (o), empty (e), or if it belongs to the interface
                          between SAS and MS (s)
double ***DeltaPrDeso --- Elec desolvation due to the occupation of a grid point
double Kelec ------------ Constant
double Ksolv ------------ Constant
double UnitVol ---------- Volume of the grid element for cont. elec.
double pi4 -------------- 4 * greekpi
int nxminBS ------------- grid point (along x) where the BS starts
int nyminBS ------------- grid point (along y) where the BS starts
int nzminBS ------------- grid point (along z) where the BS starts
int nxmaxBS ------------- grid point (along x) where the BS ends
int nymaxBS ------------- grid point (along y) where the BS ends
int nzmaxBS ------------- grid point (along z) where the BS ends
double corr_scrint ------ Correction factor for the screened interaction
                          calculated according to the GB formula
                          (slow and precise method)
double corr_fr_deso ----- Correction factor for slow frag elec desolvation
                          (fd approx.)
double *PReDesoElec ----- Rec elec desolvation
double *PReFrIntElec ---- Rec-Frag screened interaction
double *PFrDesoElec ----- Frag elec desolvation
######################################################################*/
{
  int /*unused variable :i,*/ iat,jat,ix,iy,iz,NNeigh1,*NeighList1,ExFrAtNu,Nsurfpt_ex,
      nxminFr,nyminFr,nzminFr,nxmaxFr,nymaxFr,nzmaxFr,NNeigh2,*NeighList2,
      NNeigh3,*NeighList3,nxmin_sma,nymin_sma,nzmin_sma,nxmax_sma,nymax_sma,
      nzmax_sma,nxmin_big,nymin_big,nzmin_big,nxmax_big,nymax_big,nzmax_big,
    nn, /* ,unused variables :n,ntime,*/ FrOut,hVar_corrB;
  double **ExRoSFCo,**dist,FrMinC[4],FrMaxC[4];
  double *ExFrRadOut,*ExFrRadOut2,*ExFrRad,*FrSelfVol,*ReEffRad,*FrEffRad,
      *ReSelfVol_add,FrSelfEn,FrIntEn; /*unused variable :,ReSelfEn,ReIntEn; */
  double *FrSelfVol_corrB,*ReSelfVol_add_corrB;
  char ***FrGridMat;
  struct point *surfpt_fr;
/*unused variable :  FILE *FilePa;*/
/*#######################################################################
int i,iat,jat,ix,iy,iz -- Multipurpose indices
int NNeigh1 ------------- Amount of rec atoms closer than 2*WaMoRa
                          to the fragment
int *NeighList1 --------- NeighList1[1->NNeigh1] = rec atom # closer
                          than 2*WaMoRa to the fragment
int ExFrAtNu ------------ FrAtNu + NNeigh1
int Nsurfpt_ex ---------- Tot # of SAS1 generated by the frag and
                          by those rec atoms that are at a
                          distance < 2*WaMoRa from at least 1 frag atom
int nxminFr ------------- grid point (along x) where the frag starts
int nyminFr ------------- grid point (along y) where the frag starts
int nzminFr ------------- grid point (along z) where the frag starts
int nxmaxFr ------------- grid point (along x) where the frag ends
int nymaxFr ------------- grid point (along y) where the frag ends
int nzmaxFr ------------- grid point (along z) where the frag ends
int NNeigh2 ------------- Amount of rec atoms closer than 3*WaMoRa
                          to the fragment
int *NeighList2 --------- NeighList2[1->NNeigh2] = rec atom # closer
                          than 3*WaMoRa to the fragment
int NNeigh3 ------------- Amount of rec atoms falling at least once
                          in the cutoff for non-bonded interactions
int *NeighList3 --------- NeighList3[1->NNeigh3] = rec atom # falling at least
                          once in the cutoff for non-bonded interactions
int nxmin_sma ----------- The biggest between nxminFr and nxminBS
int nymin_sma ----------- The biggest between nyminFr and nyminBS
int nzmin_sma ----------- The biggest between nzminFr and nzminBS
int nxmax_sma ----------- The smallest between nxmaxFr and nxmaxBS
int nymax_sma ----------- The smallest between nymaxFr and nymaxBS
int nzmax_sma ----------- The smallest between nzmaxFr and nzmaxBS
int nxmin_big ----------- The smallest between nxminFr and 1
int nymin_big ----------- The smallest between nyminFr and 1
int nzmin_big ----------- The smallest between nzminFr and 1
int nxmax_big ----------- The biggest between nxmaxFr and NGridx
int nymax_big ----------- The biggest between nymaxFr and NGridy
int nzmax_big ----------- The biggest between nzmaxFr and NGridz
int nn,n,ntime ---------- Multipurpose variables
int FrOut --------------- Flag telling the position of the frag respect
                          to the elec grid box:
                          0 = frag completely contained in the grid box
                          1 = fragment partially contained in the grid box
                          2 = fragment completely out of the grid box
double **ExRoSFCo -------- Coor of the frag and of those rec atoms that are at a
                          distance < 2*WaMoRa from at least 1 frag atom
double **dist ------------ Frag-rec interatomic distances
double FrMinC[4] --------- Min (along x,y,z) of RoSFCo
double FrMaxC[4] --------- Max (along x,y,z) of RoSFCo
double *ExFrRadOut ------ Charge radii + WaMoRa of the frag and of those
                          rec atoms that are at a distance < 2*WaMoRa from
                          at least 1 frag atom
double *ExFrRadOut2 ----- (Charge radii + WaMoRa)^2 of the frag and of those
                          rec atoms that are at a distance < 2*WaMoRa from
                          at least 1 frag atom
double *ExFrRad --------- Charge radii of the frag and of those
                          rec atoms that are at a distance < 2*WaMoRa from
                          at least 1 frag atom
double *FrSelfVol ------- FrSelfVol[iat] = integral of 1/r^4 over the solute
                          volume for frag atom iat
double *ReEffRad -------- ReEffRad[n] = effective radius of rec atom n
double *FrEffRad -------- FrEffRad[n] = effective radius of frag atom n
double *ReSelfVol_add --- ReSelfVol_add[iat] = integral of 1/r^4 over
                          the rec and the frag volume for rec atom iat
double FrSelfEn --------- Tot frag self-energy
double FrIntEn ---------- Tot frag intramolecular interaction energy
double ReSelfEn --------- Tot rec self-energy
double ReIntEn ---------- Tot rec intramolecular interaction energy
char ***FrGridMat ------- Small submatrix of GridMat around the frag telling the
                          volume occupied by the frag in the bound conformation
struct point *surfpt_fr - Coor of points over frag SAS1 (relative to RoSFCo)
######################################################################*/

/*  ntime = clock(); */
/* Get the position of the fragment on the precalculated grid
  printf("\tPosition of the fragment...\n");  */
  nn = get_frag_dim(FrAtNu,RoSFCo,FrRadOut,GrSiSo,WaMoRa,NGridx,
                    NGridy,NGridz,Min,&nxminFr,
                    &nyminFr,&nzminFr,&nxmaxFr,&nymaxFr,&nzmaxFr,&FrOut);
/*  printf("\t%lf\n",1e-6 * (clock()-ntime)); */

/* Get the receptor atoms that are closer than 2*WaMoRa (NeighList1) or
   than 3*WaMoRa (NeighList2) to the fragment. NeighList1 will be used
   to generate the volume enclosed by the S&R surface, while NeighList2
   will be used to generate the S&R surface
   NeighList3 is the list of the receptor atoms that fall at least once
   in the cutoff for non-bonded interactions
  printf("\tReceptor Neighbours...\n");
  ntime = clock(); */
  NeighList1 = ivector(1,ReAtNu);
  NeighList2 = ivector(1,ReAtNu);
  NeighList3 = ivector(1,ReAtNu);
  dist=dmatrix(1,FrAtNu,1,ReAtNu);
  nn = get_Rec_neigh(ReAtNu,FrAtNu,dist2,dist,ReRad,
                     FrRad,RePaCh,WaMoRa,nsurf_re,&NNeigh1,NeighList1,&NNeigh2,
                     NeighList2,&NNeigh3,NeighList3);
/*  printf("\tget_Rec_neigh %lf\n",1e-6 * (clock()-ntime)); */

/* Make some new arrays for the "Extended fragment" (= the fragment plus
   his receptor neighbours)
  printf("\tNew arrays for the ''Extended fragment''...\n"); */

  ExFrAtNu = FrAtNu + NNeigh1; // receptor neighbours from NNeigh1. clangini
  ExRoSFCo = dmatrix(1,ExFrAtNu,1,3);
  ExFrRad = dvector(1,ExFrAtNu);
  ExFrRadOut = dvector(1,ExFrAtNu);
  ExFrRadOut2 = dvector(1,ExFrAtNu);
  for (iat=1;iat<=FrAtNu;iat++) {
    ExRoSFCo[iat][1] = RoSFCo[iat][1];
    ExRoSFCo[iat][2] = RoSFCo[iat][2];
    ExRoSFCo[iat][3] = RoSFCo[iat][3];
    ExFrRad[iat] = FrRad[iat];
    ExFrRadOut[iat] = FrRadOut[iat];
    ExFrRadOut2[iat] = FrRadOut2[iat];
  }

  for (iat=FrAtNu+1,jat=1;iat<=ExFrAtNu;iat++,jat++) {
    ExRoSFCo[iat][1] = ReCoor[NeighList1[jat]][1];
    ExRoSFCo[iat][2] = ReCoor[NeighList1[jat]][2];
    ExRoSFCo[iat][3] = ReCoor[NeighList1[jat]][3];
    ExFrRad[iat] = ReRad[NeighList1[jat]];
    ExFrRadOut[iat] = ReRadOut[NeighList1[jat]];
    ExFrRadOut2[iat] = ReRadOut2[NeighList1[jat]];
  }

/* Translate and rotate the S&R surface of the fragment alone from the
   original position to the actual position
  printf("\tMoving SAS surface...\n"); */
  surfpt_fr=structpointvect(1,NPtSphere*FrAtNu);
  nn = Mov_surf(Nsurfpt_fr,surfpt_fr_orig,FrCoor,FrMinC_orig,FrMaxC_orig,
                Tr,U1,U2,surfpt_fr,FrMinC,FrMaxC);

/* Superpose the S&R surfaces of the fragment alone and of the receptor
   neighbour atoms and obtain the resulting surface
  printf("\tSurface convolution...\n");
  ntime = clock(); */
  nn = join_surf(ReCoor,ReRadOut2,surfpt_re,nsurf_re,pointsrf_re,
                 FrAtNu,RoSFCo,FrRadOut2,surfpt_fr,nsurf_fr,pointsrf_fr,
                 NNeigh2,NeighList2,&Nsurfpt_ex,surfpt_ex);
/*  printf("\tjoin_surf %lf\n",1e-6 * (clock()-ntime)); */

/* Make the map (FrGridMat) of the 3D grid points occupied by the volume
   enclosed by the SAS of the "extended fragment"
  printf("\tMap of volume enclosed by the SAS for the fragment...\n");
  ntime = clock(); */
  FrGridMat = c3tensor(nxminFr,nxmaxFr+1,nyminFr,nymaxFr+1,nzminFr,nzmaxFr+1); // Why do we use +1? clangini
  for (ix=nxminFr;ix<=nxmaxFr+1;ix++)
    for (iy=nyminFr;iy<=nymaxFr+1;iy++)
      for (iz=nzminFr;iz<=nzmaxFr+1;iz++)
        FrGridMat[ix][iy][iz] = 'e';

  nn = SAS_Volume_Fr(ExFrAtNu,ExRoSFCo,ExFrRadOut,ExFrRadOut2,Min,GrSiSo,
                     nxminFr,nyminFr,nzminFr,nxmaxFr,nymaxFr,nzmaxFr,
                     FrGridMat,GridMat,FrOut);
/*  printf("\tSAS_Volume_Fr %lf\n",1e-6 * (clock()-ntime)); */

/* Now place a sphere of radius WaMoRa on every surface grid point and
   mark as empty all the volume grid points falling inside
  printf("\n\tGeneration of volume enclosed by the MS...\n");
  ntime = clock(); */
  nn = Excl_Grid_Fr(Min,WaMoRa,GrSiSo,nxminFr,nyminFr,nzminFr,nxmaxFr,
                    nymaxFr,nzmaxFr,FrGridMat,Nsurfpt_ex,surfpt_ex);
/*  printf("\tExcl_Grid_Fr %lf\n",1e-6 * (clock()-ntime)); */

/* Check if fragment is out of the grid: if yes cut the part that is out */
  nxmin_sma = (nxminFr > nxminBS) ? nxminFr : nxminBS;
  nymin_sma = (nyminFr > nyminBS) ? nyminFr : nyminBS;
  nzmin_sma = (nzminFr > nzminBS) ? nzminFr : nzminBS;
  nxmax_sma = (nxmaxFr < nxmaxBS) ? nxmaxFr : nxmaxBS;
  nymax_sma = (nymaxFr < nymaxBS) ? nymaxFr : nymaxBS;
  nzmax_sma = (nzmaxFr < nzmaxBS) ? nzmaxFr : nzmaxBS;

  nxmin_big = (nxminFr < 1) ? nxminFr : 1;
  nymin_big = (nyminFr < 1) ? nyminFr : 1;
  nzmin_big = (nzminFr < 1) ? nzminFr : 1;
  nxmax_big = (nxmaxFr > NGridx) ? nxmaxFr : NGridx;
  nymax_big = (nymaxFr > NGridy) ? nymaxFr : NGridy;
  nzmax_big = (nzmaxFr > NGridz) ? nzmaxFr : NGridz;
//clangini debug start
/* Check if fragment is out of the grid: if yes cut the part that is out */
  // //nxmin_sma = (nxminFr > nxminBS) ? nxminFr : nxminBS;
  // if (nxminFr > nxminBS){
  //   std::cout << "nxminFr > nxminBS" << std::endl;
  //   nxmin_sma = nxminFr;
  // } else{
  //   std::cout << "Out of grid: nxminFr < nxminBS" << std::endl;
  //   nxmin_sma = nxminBS;
  // }
  // if (nyminFr > nyminBS){
  //   std::cout << "nyminFr > nyminBS" << std::endl;
  //   nymin_sma = nyminFr;
  // } else{
  //   std::cout << "Out of grid: nyminFr < nyminBS" << std::endl;
  //   nymin_sma = nyminBS;
  // }
  // if (nzminFr > nzminBS){
  //   std::cout << "nzminFr > nzminBS" << std::endl;
  //   nzmin_sma = nzminFr;
  // } else{
  //   std::cout << "Out of grid: nzminFr < nzminBS" << std::endl;
  //   nzmin_sma = nzminBS;
  // }
  // //nymin_sma = (nyminFr > nyminBS) ? nyminFr : nyminBS;
  // //nzmin_sma = (nzminFr > nzminBS) ? nzminFr : nzminBS;
  // //nxmax_sma = (nxmaxFr < nxmaxBS) ? nxmaxFr : nxmaxBS;
  // if (nxmaxFr < nxmaxBS){
  //   std::cout << "nxmaxFr < nxmaxBS" << std::endl;
  //   nxmax_sma = nxmaxFr;
  // } else{
  //   std::cout << "Out of grid: nxmaxFr > nxmaxBS" << std::endl;
  //   nxmax_sma = nxmaxBS;
  // }
  // nymax_sma = (nymaxFr < nymaxBS) ? nymaxFr : nymaxBS;
  // if (nymaxFr < nymaxBS){
  //   std::cout << "nymaxFr < nymaxBS" << std::endl;
  //   nymax_sma = nymaxFr;
  // } else{
  //   std::cout << "Out of grid: nymaxFr > nymaxBS" << std::endl;
  //   nymax_sma = nymaxBS;
  // }
  // nzmax_sma = (nzmaxFr < nzmaxBS) ? nzmaxFr : nzmaxBS;
  // if (nzmaxFr < nzmaxBS){
  //   std::cout << "nzmaxFr < nzmaxBS" << std::endl;
  //   nzmax_sma = nzmaxFr;
  // } else{
  //   std::cout << "Out of grid: nzmaxFr > nzmaxBS" << std::endl;
  //   nzmax_sma = nzmaxBS;
  // }
  // //nymax_sma = (nymaxFr < nymaxBS) ? nymaxFr : nymaxBS;
  // //nzmax_sma = (nzmaxFr < nzmaxBS) ? nzmaxFr : nzmaxBS;
  //
  // //nxmin_big = (nxminFr < 1) ? nxminFr : 1;
  // if (nxminFr < 1){
  //   std::cout << "nxminFr < 1; out of grid" << std::endl;
  //   nxmin_big = nxminFr;
  // } else{
  //   std::cout << "nxminFr >= 1" << std::endl;
  //   nxmin_big = 1;
  // }
  // if (nyminFr < 1){
  //   std::cout << "nyminFr < 1; out of grid" << std::endl;
  //   nymin_big = nyminFr;
  // } else{
  //   std::cout << "nyminFr >= 1" << std::endl;
  //   nymin_big = 1;
  // }
  // if (nzminFr < 1){
  //   std::cout << "nzminFr < 1; out of grid" << std::endl;
  //   nzmin_big = nzminFr;
  // } else{
  //   std::cout << "nzminFr >= 1" << std::endl;
  //   nzmin_big = 1;
  // }
  // //nymin_big = (nyminFr < 1) ? nyminFr : 1;
  // //nzmin_big = (nzminFr < 1) ? nzminFr : 1;
  // //nxmax_big = (nxmaxFr > NGridx) ? nxmaxFr : NGridx;
  // if (nxmaxFr > NGridx){
  //   std::cout << "nxmaxFr > NGridx; out of grid" << std::endl;
  //   nxmax_big = nxmaxFr;
  // } else{
  //   std::cout << "nxmaxFr < NGridx" << std::endl;
  //   nxmax_big = NGridx;
  // }
  // if (nymaxFr > NGridy){
  //   std::cout << "nymaxFr > NGridy; out of grid" << std::endl;
  //   nymax_big = nymaxFr;
  // } else{
  //   std::cout << "nymaxFr < NGridy" << std::endl;
  //   nymax_big = NGridy;
  // }
  // if (nzmaxFr > NGridz){
  //   std::cout << "nzmaxFr > NGridz; out of grid" << std::endl;
  //   nzmax_big = nzmaxFr;
  // } else{
  //   std::cout << "nzmaxFr < NGridz" << std::endl;
  //   nzmax_big = NGridz;
  // }
  // //nymax_big = (nymaxFr > NGridy) ? nymaxFr : NGridy;
  // //nzmax_big = (nzmaxFr > NGridz) ? nzmaxFr : NGridz;
//clangini debug end

/* Calculate protein desolvation
  printf("\n\tProtein desolvation...\n");
  printf("\tOut %d\n",FrOut); */
  *PReDesoElec = 0.;
  if ( FrOut != 2 ) // if fragment is not completely out of BS
    for (ix=nxmin_sma;ix<=nxmax_sma;ix++)
      for (iy=nymin_sma;iy<=nymax_sma;iy++)
        for (iz=nzmin_sma;iz<=nzmax_sma;iz++)
          if (FrGridMat[ix][iy][iz] == 'o')
            *PReDesoElec += DeltaPrDeso[ix][iy][iz]; // eq. (5) from SEED 3.3.6 manual

/* Calculate the effective volumes of the receptor in presence of the ligand
  printf("\n\tEffective volumes of the receptor...\n");
  ntime = clock(); */
  ReSelfVol_add=dvector(1,ReAtNu);
  ReSelfVol_add_corrB=dvector(1,ReAtNu);
  for (iat=1;iat<=ReAtNu;iat++)
  {
    ReSelfVol_add[iat] = 0.;
    ReSelfVol_add_corrB[iat] = 0.;
  }
  nn = Get_Self_Vol_Re(ReAtNu,ReCoor,NNeigh3,NeighList3,ReRad2,GrSiSo,
                       XGrid,YGrid,ZGrid,nxminFr,nyminFr,nzminFr,
                       nxmaxFr,nymaxFr,nzmaxFr,UnitVol,FrGridMat,
                       ReSelfVol_add,ReSelfVol_add_corrB,EmpCorrB);
/*  printf("\tGet_Self_Vol_Re %lf\n",1e-6 * (clock()-ntime)); */

/* Calculate the effective volumes of the ligand in the binding site
  printf("\n\tEffective volumes of the ligand...\n");
  ntime = clock(); */
  FrSelfVol=dvector(1,FrAtNu);
  FrSelfVol_corrB=dvector(1,FrAtNu);
  for (iat=1;iat<=FrAtNu;iat++)
  {
    FrSelfVol[iat] = 0.;
    FrSelfVol_corrB[iat] = 0.;
  }
  nn = Get_Self_Vol_Fr(FrAtNu,RoSFCo,FrPaCh,FrRad2,FrRadOut,FrRadOut2,
                       GrSiSo,XGrid,YGrid,ZGrid,Min,UnitVol,NGridx,NGridy,
                       NGridz,GridMat,nxminFr,nyminFr,nzminFr,
                       nxmaxFr,nymaxFr,nzmaxFr,FrGridMat,FrOut,nxmin_big,
                       nymin_big,nzmin_big,nxmax_big,nymax_big,nzmax_big,
                       FrSelfVol,FrSelfVol_corrB,EmpCorrB);
/*  printf("\tGet_Self_Vol_Fr %lf\n",1e-6 * (clock()-ntime)); */

/* Calculate the effective radii of the receptor
  printf("\n\tEffective radii of the receptor...\n"); */
  ReEffRad=dvector(1,ReAtNu);
  for (iat=1;iat<=NNeigh3;iat++) // calculate the ReEffRad only for atoms within the cutoff. clangini
  {
    if (EmpCorrB[0]!='y')
      ReEffRad[NeighList3[iat]] = 1. / ( 1./ReRadOut[NeighList3[iat]] -
             (ReSelfVol[NeighList3[iat]]+ReSelfVol_add[NeighList3[iat]])/pi4 );
    else
    {
      hVar_corrB=NeighList3[iat];


      ReEffRad[hVar_corrB] = 1./( (-1.*(1./ReRadOut[hVar_corrB] -
					(ReSelfVol[hVar_corrB]+ReSelfVol_add[hVar_corrB])/pi4))
				  + 3.0*sqrt( (1./(2.*ReRadOut[hVar_corrB]*ReRadOut[hVar_corrB])) -
					((ReSelfVol_corrB[hVar_corrB]+ReSelfVol_add_corrB[hVar_corrB])/pi4) ) )
	        + 0.215;


      /*
        Dey exception handling :
        in rare cases the expression :
        (1./(2.*ReRadOut[iat]*ReRadOut[iat])) - ((*SelfVol_corrB)[iat]/pi4)
        can become < 0 -> the sqrt() function cannot be evaluated, which leads
        to "nan" values or the effective born radius is smaller than 0
        clangini modification:
        we are able to define a lower bound on the receptor born radius.
        If the effective born radius is smaller than the lower bound, 
        it is overridden to the lower bound.
      */
      if(std::isnan(ReEffRad[hVar_corrB]) || ReEffRad[hVar_corrB] <= ReEffRad_bound[hVar_corrB])
      {
#ifndef NOWARN
	      // fprintf(FPaOut,"WARNING could not calculate empirically-corrected effective born radius of receptor atom %d using standard approach\n",iat);
        // if (!std::isnan(ReEffRad[hVar_corrB])){
        //   fprintf(FPaOut, "Calculated effective Born radius of receptor atom ");
        //   fprintf(FPaOut, "%d (%f) set to its lower bound (%f).\n", 
        //           iat, ReEffRad[hVar_corrB], ReEffRad_bound[hVar_corrB]);
        // } else {
        //   fprintf(FPaOut, "WARNING empirically-corrected effective born radius ");
        //   fprintf(FPaOut, "of receptor atom %d is nan. Set to its estimated lower bound (%f).\n", 
        //           iat, ReEffRad_bound[hVar_corrB]);
        // }
        if (!std::isnan(ReEffRad[hVar_corrB]) && (ReEffRad[hVar_corrB] / ReEffRad_bound[hVar_corrB] < 0.9))
        { // write warning only if difference is more than 10%
          fprintf(FPaOut, "Calculated effective Born radius of receptor atom ");
          fprintf(FPaOut, "%d (%f) set to its lower bound (%f).\n",
                    iat, ReEffRad[hVar_corrB], ReEffRad_bound[hVar_corrB]);
        }
#endif
        //clangini debug start
        //std::cout << "Eff radius either none or zero" << std::cout;
        //clangini debug end
	      // ReEffRad[NeighList3[iat]] = 1. / ( 1./ReRadOut[NeighList3[iat]] -
				// 	     (ReSelfVol[NeighList3[iat]]+ReSelfVol_add[NeighList3[iat]])/pi4 );
        ReEffRad[hVar_corrB] = ReEffRad_bound[hVar_corrB];
      }
    }
  }

/* Receptor desolvation calculated with GB (it could be useful one day...)
  ReSelfEn = 0.;
  for (iat=1;iat<=NNeigh3;iat++) {
    ReSelfEn += Ksolv * RePaCh[NeighList3[iat]] * RePaCh[NeighList3[iat]] /
                (2. * ReEffRad[NeighList3[iat]]);
  }
  nn = GB_int_re(ReAtNu,ReCoor,RePaCh,ReEffRad,Ksolv,&ReIntEn);
  printf("deso %lf\n",ReSelfEn+ReIntEn-7745.587392+10320.308710);
*/

/* Calculate frag self energy */
  FrEffRad=dvector(1,FrAtNu);
  FrSelfEn = 0.;

/* #ifdef OMP */
/* #pragma omp parallel for default(none) shared(FrEffRad) reduction(+:FrSelfEn) */
/* #endif */
  for (iat=1;iat<=FrAtNu;iat++)
    if (FrPaCh[iat] != 0. ) {

      if (EmpCorrB[0]!='y')
        FrEffRad[iat] = 1. / ( 1./FrRadOut[iat] - FrSelfVol[iat]/pi4 );
      else
      {

	       FrEffRad[iat] = 1./( (-1.*(1./FrRadOut[iat] - FrSelfVol[iat]/pi4))
			       + 3.0*sqrt( (1./(2.*FrRadOut[iat]*FrRadOut[iat])) -
					   (FrSelfVol_corrB[iat]/pi4) ) )
	           + 0.215;

	  /*
	    Dey exception handling :
	    in rare cases the expression :
	    (1./(2.*ReRadOut[iat]*ReRadOut[iat])) - ((*SelfVol_corrB)[iat]/pi4)
	    can become < 0 -> the sqrt() function cannot be evaluated, which leads
	    to "nan" values or the effective born radius is smaller than 0

	  */
	  if(std::isnan(FrEffRad[iat]) || (FrEffRad[iat] <= FrEffRad_bound[iat]))
	  {
#ifndef NOWARN
	      // fprintf(FPaOut,"WARNING could not calculate empirically-corrected effective born radius of fragment atom %d, using standard approach\n",iat);
        // if(!std::isnan(FrEffRad[iat])){
        //   fprintf(FPaOut, "Calculated effective Born radius of fragment atom %d (%f) set to its lower bound (%f).\n", iat, FrEffRad[iat], FrEffRad_bound[iat]);
        // } else {
        //   fprintf(FPaOut, "WARNING empirically-corrected effective born radius of fragment atom %d is nan. Set to its estimated lower bound (%f).\n", iat, FrEffRad_bound[iat]);
        // }
        if (!std::isnan(FrEffRad[iat]) && (FrEffRad[iat] / FrEffRad_bound[iat] < 0.9))
        {
          fprintf(FPaOut, "Calculated effective Born radius of fragment atom %d (%f) set to its lower bound (%f).\n", iat, FrEffRad[iat], FrEffRad_bound[iat]);
        }
#endif
        //clangini debug start
        //std::cout << "Eff radius either none or zero" << std::cout;
        //clangini debug end
	      // FrEffRad[iat] = 1. / ( 1./FrRadOut[iat] - FrSelfVol[iat]/pi4 );
        FrEffRad[iat] = FrEffRad_bound[iat];
	  }
  }
   FrSelfEn += Ksolv * FrPaCh[iat] * FrPaCh[iat] / (2. * FrEffRad[iat]);
  }

/* Calculate the electrostatic intermolecular interactions
  printf("\n\tElectrostatic intermolecular interactions...\n"); */
  nn = screened_int(RePaCh_Fr,ReEffRad,NNeigh3,NeighList3,FrAtNu,FrPaCh,
                    FrEffRad,dist2,dist,Kelec,Ksolv,PReFrIntElec);
  *PReFrIntElec *= corr_scrint;

/* Calculate the electrostatic intra-ligand interactions
  printf("\n\tElectrostatic intra-ligand interactions...\n"); */
  nn = GB_int_fr(FrAtNu,Frdist2,FrPaCh,FrEffRad,Ksolv,&FrIntEn);

  // clangini debug
  // std::cout << "FrSelfEn = " << FrSelfEn << " FrIntEn = " << FrIntEn;
  // clangini debug end

  *PFrDesoElec = FrSelfEn + FrIntEn;
  *PFrDesoElec -= *PFrSolvEn;
  *PFrDesoElec *= corr_fr_deso;

  // std::cout << "  Corr frg. desolv:  " << *PFrDesoElec << "\n";

  free_dmatrix(dist,1,FrAtNu,1,ReAtNu);
  free_dvector(FrSelfVol,1,FrAtNu); /* dey memory leak */
  free_dvector(FrSelfVol_corrB,1,FrAtNu); /* dey memory leak */
  free_dvector(ReSelfVol_add,1,ReAtNu);
  free_dvector(ReSelfVol_add_corrB,1,ReAtNu);
  free_dvector(ReEffRad,1,ReAtNu);
  free_dvector(FrEffRad,1,FrAtNu);
  free_structpointvect(surfpt_fr,1,NPtSphere*FrAtNu);
  free_ivector(NeighList3,1,ReAtNu);
  free_ivector(NeighList2,1,ReAtNu);
  free_ivector(NeighList1,1,ReAtNu);
  free_dvector(ExFrRadOut2,1,ExFrAtNu);
  free_dvector(ExFrRadOut,1,ExFrAtNu);
  free_dvector(ExFrRad,1,ExFrAtNu);
  free_dmatrix(ExRoSFCo,1,ExFrAtNu,1,3);
  free_c3tensor(FrGridMat,nxminFr,nxmaxFr+1,nyminFr,
                nymaxFr+1,nzminFr,nzmaxFr+1);

/*  printf("\tSlow Desol %lf\n",1e-6 * (clock()-ntime)); */
}

void CalcEffRad(int ReAtNu, double **ReCoor, double *RePaCh,
                double *ReRad, double *ReRad2, 
                double *ReRadOut, double *ReRadOut2,
                double *ReEffRad_bound,
                struct point *surfpt_re, int *nsurf_re,
                int *pointsrf_re, double *ReSelfVol, int FrAtNu, double **RoSFCo,
                double **FrCoor, double *FrPaCh, double *FrRad, double *FrRad2,
                double *FrRadOut, double *FrRadOut2,
                double *FrEffRad_bound,
                double **Frdist2, double **dist2,
                double *FrMinC_orig, double *FrMaxC_orig,
                int Nsurfpt_fr, struct point *surfpt_fr_orig,
                int *nsurf_fr, int *pointsrf_fr, struct point *surfpt_ex,
                double Tr[4], double U1[4][4], double U2[4][4], double WaMoRa,
                double GrSiSo, int NPtSphere, struct point Min,
                struct point Max, double *XGrid, double *YGrid, double *ZGrid,
                int NGridx, int NGridy, int NGridz, char ***GridMat,
                double Kelec, double Ksolv, double UnitVol, double pi4,
                double *ReSelfVol_corrB, char *EmpCorrB, FILE *FPaOut,
                double *ReEffRad, double *FrEffRad,
                int *NeighList3, int *PNNeigh3)
/*########################################################################
Continuum Electrostatics: Born effective radii and exports the neighbour,
lists needed for the calculation of continuum electrostatics with the 
slow and precise method.
This function is a mod of ElecFrag().
########################################################################*/

/*#######################################################################
int ReAtNu -------------- Tot # rec atoms
double **ReCoor ---------- Rec Coordinates
double *RePaCh ----------- Rec partial charges
double *RePaCh_Fr -------- Modified rec partial charges (for the charged residues
                          around the BS a unit charge is assigned to the atom
                          closest to the charge center
double *ReRad ----------- Rec charge radii (=vdW radii apart "enclosed" H)
double *ReRad2 ---------- (Rec charge radii)^2
double *ReRadOut -------- Rec charge radii + WaMoRa
double *ReRadOut2 ------- (Rec charge radii + WaMoRa)^2

==============================================================================
                  SAS1 is a SAS built to obtain the volume enclosed by the MS
                  SAS2 is a SAS built for a fast evaluation of the desolvation
                  SAS3 is a SAS built to estimate the surface hydrophobicity
==============================================================================

struct point *surfpt_re - Coor of points over rec SAS1
int *nsurf_re ----------- nsurf_re[n] = amount of SAS1 surface points
                          generated by rec atom n
int *pointsrf_re -------- pointsrf_re[n] = first rec SAS1 point (in the
                          list surfpt_re) that is generated by rec atom n
double **ReSelfVol ------ ReSelfVol[iat] = integral of 1/r^4 over the receptor
                          volume for atom iat
int FrAtNu -------------- Tot # frag atoms
double **RoSFCo ---------- Frag coordinates in the seeded conformation
double **FrCoor ---------- Frag coordinates in the original location
double *FrPaCh ----------- Frag partial charges
double *FrRad ----------- Frag charge radii (=vdW radii apart "enclosed" H)
double *FrRad2 ---------- (Frag charge radii)^2
double *FrRadOut -------- Frag charge radii + WaMoRa
double *FrRadOut2 ------- (Frag charge radii + WaMoRa)^2
double **Frdist2 --------- Squared interatomic frag distances
double **dist2 ----------- Squared interatomic rec-frag distances
double *FrMinC_orig ------ Min (along x,y,z) of FrCoor
double *FrMaxC_orig ------ Max (along x,y,z) of FrCoor
double *PFrSolvEn ------- Frag solvation energy
int Nsurfpt_fr ---------- Tot # of points over the frag SAS1
struct point *surfpt_fr_orig - Coor of points over frag SAS1 (obtained from
                               FrCoor coordinates)
int *nsurf_fr ----------- nsurf_fr[n] = amount of SAS1 surface points
                          generated by frag atom n
int *pointsrf_fr -------- pointsrf_fr[n] = first frag SAS1 point (in the
                          list surfpt_fr) that is generated by frag atom n
struct point *surfpt_ex - Coor of points over SAS1 generated by the frag and
                          by those rec atoms that are at a distance < 2*WaMoRa
                          from at least 1 frag atom
double Tr[4] ------------ Translation vector to superimpose the first atom of
                          FrCoor with the first of RoSFCo
double U1[4][4] --------- Rotation matrix around the axis passing by the 1st atom
                          of FrCoor and perpendicular to the plane formed by the
                          vector joining the 1st atom and the 2nd atom of FrCoor
                          and the vector joining the 1st atom and the 2nd atom of
                          RoSFCo. The rotation angle is such that it superimpose
                          the 2nd atom of RoSFCo with the 2nd atom of FrCoor
double U2[4][4] --------- Rotation matrix around the axis joining the 1st atom and
                          the 2nd atom of RoSFCo in order to superimpose
                          the 3rd atom of RoSFCo with the 3rd atom of FrCoor
double WaMoRa ----------- Radius of the water molecule
double GrSiSo ----------- Size of the 3D grid used for cont. electrostatics
double GrInSo ----------- Margin left along each dimension (positive and
                          negative) of the rec for building the 3D grid box
int NPtSphere ----------- Amount of points placed over each atom to generate
                          the SAS (built in order to obtain the volume
                          enclosed by the MS)
struct point Min -------- Min coor of the grid box
struct point Max -------- Max coor of the grid box
double *XGrid ----------- X coor of the grid points
double *YGrid ----------- Y coor of the grid points
double *ZGrid ----------- Z coor of the grid points
int  NGridx ------------- Tot # of grid points along x
int  NGridy ------------- Tot # of grid points along y
int  NGridz ------------- Tot # of grid points along z
char ***GridMat --------- Matrix telling if a grid point is occupied by the
                          rec (o), empty (e), or if it belongs to the interface
                          between SAS and MS (s)
double ***DeltaPrDeso --- Elec desolvation due to the occupation of a grid point
double Kelec ------------ Constant
double Ksolv ------------ Constant
double UnitVol ---------- Volume of the grid element for cont. elec.
double pi4 -------------- 4 * greekpi
int nxminBS ------------- grid point (along x) where the BS starts
int nyminBS ------------- grid point (along y) where the BS starts
int nzminBS ------------- grid point (along z) where the BS starts
int nxmaxBS ------------- grid point (along x) where the BS ends
int nymaxBS ------------- grid point (along y) where the BS ends
int nzmaxBS ------------- grid point (along z) where the BS ends
double corr_scrint ------ Correction factor for the screened interaction
                          calculated according to the GB formula
                          (slow and precise method)
double corr_fr_deso ----- Correction factor for slow frag elec desolvation
                          (fd approx.)
double *PReDesoElec ----- Rec elec desolvation
double *PReFrIntElec ---- Rec-Frag screened interaction
double *PFrDesoElec ----- Frag elec desolvation
######################################################################*/
{
  int /*unused variable :i,*/ iat, jat, ix, iy, iz, NNeigh1, *NeighList1, ExFrAtNu, Nsurfpt_ex,
      nxminFr, nyminFr, nzminFr, nxmaxFr, nymaxFr, nzmaxFr, NNeigh2, *NeighList2,NNeigh3,
      // nxmin_sma, nymin_sma, nzmin_sma, nxmax_sma, nymax_sma, nzmax_sma, 
      nxmin_big, nymin_big, nzmin_big, nxmax_big, nymax_big, nzmax_big,
      nn, /* ,unused variables :n,ntime,*/ FrOut, hVar_corrB;
  double **ExRoSFCo, **dist, FrMinC[4], FrMaxC[4];
  double *ExFrRadOut, *ExFrRadOut2, *ExFrRad, *FrSelfVol,
      *ReSelfVol_add, FrSelfEn, FrIntEn; /*unused variable :,ReSelfEn,ReIntEn; */
  double *FrSelfVol_corrB, *ReSelfVol_add_corrB;
  char ***FrGridMat;
  struct point *surfpt_fr;
/*#######################################################################
int i,iat,jat,ix,iy,iz -- Multipurpose indices
int NNeigh1 ------------- Amount of rec atoms closer than 2*WaMoRa
                          to the fragment
int *NeighList1 --------- NeighList1[1->NNeigh1] = rec atom # closer
                          than 2*WaMoRa to the fragment
int ExFrAtNu ------------ FrAtNu + NNeigh1
int Nsurfpt_ex ---------- Tot # of SAS1 generated by the frag and
                          by those rec atoms that are at a
                          distance < 2*WaMoRa from at least 1 frag atom
int nxminFr ------------- grid point (along x) where the frag starts
int nyminFr ------------- grid point (along y) where the frag starts
int nzminFr ------------- grid point (along z) where the frag starts
int nxmaxFr ------------- grid point (along x) where the frag ends
int nymaxFr ------------- grid point (along y) where the frag ends
int nzmaxFr ------------- grid point (along z) where the frag ends
int NNeigh2 ------------- Amount of rec atoms closer than 3*WaMoRa
                          to the fragment
int *NeighList2 --------- NeighList2[1->NNeigh2] = rec atom # closer
                          than 3*WaMoRa to the fragment
int NNeigh3 ------------- Amount of rec atoms falling at least once
                          in the cutoff for non-bonded interactions
int *NeighList3 --------- NeighList3[1->NNeigh3] = rec atom # falling at least
                          once in the cutoff for non-bonded interactions
int nxmin_sma ----------- The biggest between nxminFr and nxminBS
int nymin_sma ----------- The biggest between nyminFr and nyminBS
int nzmin_sma ----------- The biggest between nzminFr and nzminBS
int nxmax_sma ----------- The smallest between nxmaxFr and nxmaxBS
int nymax_sma ----------- The smallest between nymaxFr and nymaxBS
int nzmax_sma ----------- The smallest between nzmaxFr and nzmaxBS
int nxmin_big ----------- The smallest between nxminFr and 1
int nymin_big ----------- The smallest between nyminFr and 1
int nzmin_big ----------- The smallest between nzminFr and 1
int nxmax_big ----------- The biggest between nxmaxFr and NGridx
int nymax_big ----------- The biggest between nymaxFr and NGridy
int nzmax_big ----------- The biggest between nzmaxFr and NGridz
int nn,n,ntime ---------- Multipurpose variables
int FrOut --------------- Flag telling the position of the frag respect
                          to the elec grid box:
                          0 = frag completely contained in the grid box
                          1 = fragment partially contained in the grid box
                          2 = fragment completely out of the grid box
double **ExRoSFCo -------- Coor of the frag and of those rec atoms that are at a
                          distance < 2*WaMoRa from at least 1 frag atom
double **dist ------------ Frag-rec interatomic distances
double FrMinC[4] --------- Min (along x,y,z) of RoSFCo
double FrMaxC[4] --------- Max (along x,y,z) of RoSFCo
double *ExFrRadOut ------ Charge radii + WaMoRa of the frag and of those
                          rec atoms that are at a distance < 2*WaMoRa from
                          at least 1 frag atom
double *ExFrRadOut2 ----- (Charge radii + WaMoRa)^2 of the frag and of those
                          rec atoms that are at a distance < 2*WaMoRa from
                          at least 1 frag atom
double *ExFrRad --------- Charge radii of the frag and of those
                          rec atoms that are at a distance < 2*WaMoRa from
                          at least 1 frag atom
double *FrSelfVol ------- FrSelfVol[iat] = integral of 1/r^4 over the solute
                          volume for frag atom iat
double *ReEffRad -------- ReEffRad[n] = effective radius of rec atom n
double *FrEffRad -------- FrEffRad[n] = effective radius of frag atom n
double *ReSelfVol_add --- ReSelfVol_add[iat] = integral of 1/r^4 over
                          the rec and the frag volume for rec atom iat
double FrSelfEn --------- Tot frag self-energy
double FrIntEn ---------- Tot frag intramolecular interaction energy
double ReSelfEn --------- Tot rec self-energy
double ReIntEn ---------- Tot rec intramolecular interaction energy
char ***FrGridMat ------- Small submatrix of GridMat around the frag telling the
                          volume occupied by the frag in the bound conformation
struct point *surfpt_fr - Coor of points over frag SAS1 (relative to RoSFCo)
######################################################################*/

  /* Get the position of the fragment on the precalculated grid
  printf("\tPosition of the fragment...\n");  */
  nn = get_frag_dim(FrAtNu, RoSFCo, FrRadOut, GrSiSo, WaMoRa, NGridx,
                    NGridy, NGridz, Min, &nxminFr,
                    &nyminFr, &nzminFr, &nxmaxFr, &nymaxFr, &nzmaxFr, &FrOut);

  /* Get the receptor atoms that are closer than 2*WaMoRa (NeighList1) or
   than 3*WaMoRa (NeighList2) to the fragment. NeighList1 will be used
   to generate the volume enclosed by the S&R surface, while NeighList2
   will be used to generate the S&R surface
   NeighList3 is the list of the receptor atoms that fall at least once
   in the cutoff for non-bonded interactions
  printf("\tReceptor Neighbours...\n");
  ntime = clock(); */
  NeighList1 = ivector(1, ReAtNu);
  NeighList2 = ivector(1, ReAtNu);
  // NeighList3 = ivector(1, ReAtNu);
  dist = dmatrix(1, FrAtNu, 1, ReAtNu);
  nn = get_Rec_neigh(ReAtNu, FrAtNu, dist2, dist, ReRad,
                     FrRad, RePaCh, WaMoRa, nsurf_re, &NNeigh1, NeighList1, &NNeigh2,
                     NeighList2, &NNeigh3, NeighList3);
  /*  printf("\tget_Rec_neigh %lf\n",1e-6 * (clock()-ntime)); */

  /* Make some new arrays for the "Extended fragment" (= the fragment plus
   his receptor neighbours)
  printf("\tNew arrays for the ''Extended fragment''...\n"); */

  ExFrAtNu = FrAtNu + NNeigh1; // receptor neighbours from NNeigh1. clangini
  ExRoSFCo = dmatrix(1, ExFrAtNu, 1, 3);
  ExFrRad = dvector(1, ExFrAtNu);
  ExFrRadOut = dvector(1, ExFrAtNu);
  ExFrRadOut2 = dvector(1, ExFrAtNu);
  for (iat = 1; iat <= FrAtNu; iat++)
  {
    ExRoSFCo[iat][1] = RoSFCo[iat][1];
    ExRoSFCo[iat][2] = RoSFCo[iat][2];
    ExRoSFCo[iat][3] = RoSFCo[iat][3];
    ExFrRad[iat] = FrRad[iat];
    ExFrRadOut[iat] = FrRadOut[iat];
    ExFrRadOut2[iat] = FrRadOut2[iat];
  }

  for (iat = FrAtNu + 1, jat = 1; iat <= ExFrAtNu; iat++, jat++)
  {
    ExRoSFCo[iat][1] = ReCoor[NeighList1[jat]][1];
    ExRoSFCo[iat][2] = ReCoor[NeighList1[jat]][2];
    ExRoSFCo[iat][3] = ReCoor[NeighList1[jat]][3];
    ExFrRad[iat] = ReRad[NeighList1[jat]];
    ExFrRadOut[iat] = ReRadOut[NeighList1[jat]];
    ExFrRadOut2[iat] = ReRadOut2[NeighList1[jat]];
  }

  /* Translate and rotate the S&R surface of the fragment alone from the
   original position to the actual position
  printf("\tMoving SAS surface...\n"); */
  surfpt_fr = structpointvect(1, NPtSphere * FrAtNu);
  nn = Mov_surf(Nsurfpt_fr, surfpt_fr_orig, FrCoor, FrMinC_orig, FrMaxC_orig,
                Tr, U1, U2, surfpt_fr, FrMinC, FrMaxC);

  /* Superpose the S&R surfaces of the fragment alone and of the receptor
   neighbour atoms and obtain the resulting surface
  printf("\tSurface convolution...\n");
  ntime = clock(); */
  nn = join_surf(ReCoor, ReRadOut2, surfpt_re, nsurf_re, pointsrf_re,
                 FrAtNu, RoSFCo, FrRadOut2, surfpt_fr, nsurf_fr, pointsrf_fr,
                 NNeigh2, NeighList2, &Nsurfpt_ex, surfpt_ex);
  /*  printf("\tjoin_surf %lf\n",1e-6 * (clock()-ntime)); */

  /* Make the map (FrGridMat) of the 3D grid points occupied by the volume
   enclosed by the SAS of the "extended fragment"
  printf("\tMap of volume enclosed by the SAS for the fragment...\n");
  ntime = clock(); */
  FrGridMat = c3tensor(nxminFr, nxmaxFr + 1, nyminFr, nymaxFr + 1, nzminFr, nzmaxFr + 1); // Why do we use +1? clangini
  for (ix = nxminFr; ix <= nxmaxFr + 1; ix++)
    for (iy = nyminFr; iy <= nymaxFr + 1; iy++)
      for (iz = nzminFr; iz <= nzmaxFr + 1; iz++)
        FrGridMat[ix][iy][iz] = 'e';

  nn = SAS_Volume_Fr(ExFrAtNu, ExRoSFCo, ExFrRadOut, ExFrRadOut2, Min, GrSiSo,
                     nxminFr, nyminFr, nzminFr, nxmaxFr, nymaxFr, nzmaxFr,
                     FrGridMat, GridMat, FrOut);
  /*  printf("\tSAS_Volume_Fr %lf\n",1e-6 * (clock()-ntime)); */

  /* Now place a sphere of radius WaMoRa on every surface grid point and
   mark as empty all the volume grid points falling inside
  printf("\n\tGeneration of volume enclosed by the MS...\n");
  ntime = clock(); */
  nn = Excl_Grid_Fr(Min, WaMoRa, GrSiSo, nxminFr, nyminFr, nzminFr, nxmaxFr,
                    nymaxFr, nzmaxFr, FrGridMat, Nsurfpt_ex, surfpt_ex);
  /*  printf("\tExcl_Grid_Fr %lf\n",1e-6 * (clock()-ntime)); */

  /* Check if fragment is out of the grid: if yes cut the part that is out */
  // nxmin_sma = (nxminFr > nxminBS) ? nxminFr : nxminBS;
  // nymin_sma = (nyminFr > nyminBS) ? nyminFr : nyminBS;
  // nzmin_sma = (nzminFr > nzminBS) ? nzminFr : nzminBS;
  // nxmax_sma = (nxmaxFr < nxmaxBS) ? nxmaxFr : nxmaxBS;
  // nymax_sma = (nymaxFr < nymaxBS) ? nymaxFr : nymaxBS;
  // nzmax_sma = (nzmaxFr < nzmaxBS) ? nzmaxFr : nzmaxBS;

  nxmin_big = (nxminFr < 1) ? nxminFr : 1;
  nymin_big = (nyminFr < 1) ? nyminFr : 1;
  nzmin_big = (nzminFr < 1) ? nzminFr : 1;
  nxmax_big = (nxmaxFr > NGridx) ? nxmaxFr : NGridx;
  nymax_big = (nymaxFr > NGridy) ? nymaxFr : NGridy;
  nzmax_big = (nzmaxFr > NGridz) ? nzmaxFr : NGridz;
  
  /* Calculate protein desolvation
  printf("\n\tProtein desolvation...\n");
  printf("\tOut %d\n",FrOut); */
  // *PReDesoElec = 0.;
  // if (FrOut != 2) // if fragment is not completely out of BS
  //   for (ix = nxmin_sma; ix <= nxmax_sma; ix++)
  //     for (iy = nymin_sma; iy <= nymax_sma; iy++)
  //       for (iz = nzmin_sma; iz <= nzmax_sma; iz++)
  //         if (FrGridMat[ix][iy][iz] == 'o')
  //           *PReDesoElec += DeltaPrDeso[ix][iy][iz]; // eq. (5) from SEED 3.3.6 manual

  /* Calculate the effective volumes of the receptor in presence of the ligand
  printf("\n\tEffective volumes of the receptor...\n");
  ntime = clock(); */
  ReSelfVol_add = dvector(1, ReAtNu);
  ReSelfVol_add_corrB = dvector(1, ReAtNu);
  for (iat = 1; iat <= ReAtNu; iat++)
  {
    ReSelfVol_add[iat] = 0.;
    ReSelfVol_add_corrB[iat] = 0.;
  }
  nn = Get_Self_Vol_Re(ReAtNu, ReCoor, NNeigh3, NeighList3, ReRad2, GrSiSo,
                       XGrid, YGrid, ZGrid, nxminFr, nyminFr, nzminFr,
                       nxmaxFr, nymaxFr, nzmaxFr, UnitVol, FrGridMat,
                       ReSelfVol_add, ReSelfVol_add_corrB, EmpCorrB);
  /*  printf("\tGet_Self_Vol_Re %lf\n",1e-6 * (clock()-ntime)); */

  /* Calculate the effective volumes of the ligand in the binding site
  printf("\n\tEffective volumes of the ligand...\n");
  ntime = clock(); */
  FrSelfVol = dvector(1, FrAtNu);
  FrSelfVol_corrB = dvector(1, FrAtNu);
  for (iat = 1; iat <= FrAtNu; iat++)
  {
    FrSelfVol[iat] = 0.;
    FrSelfVol_corrB[iat] = 0.;
  }
  nn = Get_Self_Vol_Fr(FrAtNu, RoSFCo, FrPaCh, FrRad2, FrRadOut, FrRadOut2,
                       GrSiSo, XGrid, YGrid, ZGrid, Min, UnitVol, NGridx, NGridy,
                       NGridz, GridMat, nxminFr, nyminFr, nzminFr,
                       nxmaxFr, nymaxFr, nzmaxFr, FrGridMat, FrOut, nxmin_big,
                       nymin_big, nzmin_big, nxmax_big, nymax_big, nzmax_big,
                       FrSelfVol, FrSelfVol_corrB, EmpCorrB);
  /*  printf("\tGet_Self_Vol_Fr %lf\n",1e-6 * (clock()-ntime)); */

  /* Calculate the effective radii of the receptor
  printf("\n\tEffective radii of the receptor...\n"); */
  for (iat = 1; iat <= NNeigh3; iat++) // calculate the ReEffRad only for atoms within the cutoff. clangini
  {
    if (EmpCorrB[0] != 'y')
      ReEffRad[NeighList3[iat]] = 1. / (1. / ReRadOut[NeighList3[iat]] -
                                        (ReSelfVol[NeighList3[iat]] + ReSelfVol_add[NeighList3[iat]]) / pi4);
    else
    {
      hVar_corrB = NeighList3[iat];

      ReEffRad[hVar_corrB] = 1. / ((-1. * (1. / ReRadOut[hVar_corrB] -
                                           (ReSelfVol[hVar_corrB] + ReSelfVol_add[hVar_corrB]) / pi4)) +
                                   3.0 * sqrt((1. / (2. * ReRadOut[hVar_corrB] * ReRadOut[hVar_corrB])) -
                                              ((ReSelfVol_corrB[hVar_corrB] + ReSelfVol_add_corrB[hVar_corrB]) / pi4))) +
                             0.215;
      if (std::isnan(ReEffRad[hVar_corrB]) || ReEffRad[hVar_corrB] <= ReEffRad_bound[hVar_corrB])
      {
#ifndef NOWARN
        if (!std::isnan(ReEffRad[hVar_corrB]) && (ReEffRad[hVar_corrB] / ReEffRad_bound[hVar_corrB] < 0.9))
        { // write warning only if difference is more than 10%
          fprintf(FPaOut, "Calculated effective Born radius of receptor atom ");
          fprintf(FPaOut, "%d (%f) set to its lower bound (%f).\n",
                  iat, ReEffRad[hVar_corrB], ReEffRad_bound[hVar_corrB]);
        }
#endif
        ReEffRad[hVar_corrB] = ReEffRad_bound[hVar_corrB];
      }
    }
  }

  /* Receptor desolvation calculated with GB (it could be useful one day...)
  ReSelfEn = 0.;
  for (iat=1;iat<=NNeigh3;iat++) {
    ReSelfEn += Ksolv * RePaCh[NeighList3[iat]] * RePaCh[NeighList3[iat]] /
                (2. * ReEffRad[NeighList3[iat]]);
  }
  nn = GB_int_re(ReAtNu,ReCoor,RePaCh,ReEffRad,Ksolv,&ReIntEn);
  printf("deso %lf\n",ReSelfEn+ReIntEn-7745.587392+10320.308710);
*/

  /* Calculate frag self energy */
  // FrSelfEn = 0.;

  /* #ifdef OMP */
  /* #pragma omp parallel for default(none) shared(FrEffRad) reduction(+:FrSelfEn) */
  /* #endif */
  for (iat = 1; iat <= FrAtNu; iat++)
    if (FrPaCh[iat] != 0.)
    {

      if (EmpCorrB[0] != 'y')
        FrEffRad[iat] = 1. / (1. / FrRadOut[iat] - FrSelfVol[iat] / pi4);
      else
      {

        FrEffRad[iat] = 1. / ((-1. * (1. / FrRadOut[iat] - FrSelfVol[iat] / pi4)) + 
                        3.0 * sqrt((1. / (2. * FrRadOut[iat] * FrRadOut[iat])) -
                        (FrSelfVol_corrB[iat] / pi4))) + 0.215;
        if (std::isnan(FrEffRad[iat]) || (FrEffRad[iat] <= FrEffRad_bound[iat]))
        {
#ifndef NOWARN
          if (!std::isnan(FrEffRad[iat]) && (FrEffRad[iat] / FrEffRad_bound[iat] < 0.9))
          {
            fprintf(FPaOut, "Calculated effective Born radius of fragment atom %d (%f) set to its lower bound (%f).\n", iat, FrEffRad[iat], FrEffRad_bound[iat]);
          }
#endif
          FrEffRad[iat] = FrEffRad_bound[iat];
        }
      }
      //FrSelfEn += Ksolv * FrPaCh[iat] * FrPaCh[iat] / (2. * FrEffRad[iat]);
    }

  /* Calculate the electrostatic intermolecular interactions
  printf("\n\tElectrostatic intermolecular interactions...\n"); */
  // nn = screened_int(RePaCh_Fr, ReEffRad, NNeigh3, NeighList3, FrAtNu, FrPaCh,
  //                   FrEffRad, dist2, dist, Kelec, Ksolv, PReFrIntElec);
  // *PReFrIntElec *= corr_scrint;

  /* Calculate the electrostatic intra-ligand interactions
  printf("\n\tElectrostatic intra-ligand interactions...\n"); */
  //nn = GB_int_fr(FrAtNu, Frdist2, FrPaCh, FrEffRad, Ksolv, &FrIntEn);

  //*PFrDesoElec = FrSelfEn + FrIntEn;
  //*PFrDesoElec -= *PFrSolvEn;
  //*PFrDesoElec *= corr_fr_deso;
  *PNNeigh3 = NNeigh3;

  free_dmatrix(dist, 1, FrAtNu, 1, ReAtNu);
  free_dvector(FrSelfVol, 1, FrAtNu);       /* dey memory leak */
  free_dvector(FrSelfVol_corrB, 1, FrAtNu); /* dey memory leak */
  free_dvector(ReSelfVol_add, 1, ReAtNu);
  free_dvector(ReSelfVol_add_corrB, 1, ReAtNu);
  free_structpointvect(surfpt_fr, 1, NPtSphere * FrAtNu);
  // free_ivector(NeighList3, 1, ReAtNu);
  free_ivector(NeighList2, 1, ReAtNu);
  free_ivector(NeighList1, 1, ReAtNu);
  free_dvector(ExFrRadOut2, 1, ExFrAtNu);
  free_dvector(ExFrRadOut, 1, ExFrAtNu);
  free_dvector(ExFrRad, 1, ExFrAtNu);
  free_dmatrix(ExRoSFCo, 1, ExFrAtNu, 1, 3);
  free_c3tensor(FrGridMat, nxminFr, nxmaxFr + 1, nyminFr,
                nymaxFr + 1, nzminFr, nzmaxFr + 1);
  /*  printf("\tSlow Desol %lf\n",1e-6 * (clock()-ntime)); */
}

int get_frag_dim(int FrAtNu,double **RoSFCo,double *FrRadOut,double GrSiSo,
                 double WaMoRa,int NGridx,int NGridy,int NGridz,
                 struct point Min,int *PnxminFr,
                 int *PnyminFr,int *PnzminFr,int *PnxmaxFr,
                 int *PnymaxFr,int *PnzmaxFr,int *PFrOut)
/*##########################################
Get the position of the seeded frag with respect to the elec grid
###########################################*/

/*##########################################
int FrAtNu -------------- Tot # frag atoms
double **RoSFCo ---------- Frag coordinates in the seeded conformation
double *FrRadOut -------- Frag charge radii + WaMoRa
double GrSiSo ----------- Size of the 3D grid used for cont. electrostatics
double WaMoRa ----------- Radius of the water molecule
int  NGridx ------------- Tot # of grid points along x
int  NGridy ------------- Tot # of grid points along y
int  NGridz ------------- Tot # of grid points along z
struct point Min -------- Min coor of the grid box
int *PnxminFr ----------- grid point (along x) where the frag starts
int *PnyminFr ----------- grid point (along y) where the frag starts
int *PnzminFr ----------- grid point (along z) where the frag starts
int *PnxmaxFr ----------- grid point (along x) where the frag ends
int *PnymaxFr ----------- grid point (along y) where the frag ends
int *PnzmaxFr ----------- grid point (along z) where the frag ends
int *PFrOut ------------- Flag telling the position of the frag respect
                          to the elec grid box:
                          0 = frag completely contained in the grid box
                          1 = fragment partially contained in the grid box
                          2 = fragment completely out of the grid box
###########################################*/
{
  int iat,nxlow,nylow,nzlow,nxhi,nyhi,nzhi;

  *PnxminFr = (RoSFCo[1][1] - FrRadOut[1] - WaMoRa - Min.x) / GrSiSo + 1;
  *PnyminFr = (RoSFCo[1][2] - FrRadOut[1] - WaMoRa - Min.y) / GrSiSo + 1;
  *PnzminFr = (RoSFCo[1][3] - FrRadOut[1] - WaMoRa - Min.z) / GrSiSo + 1;
  *PnxmaxFr = (RoSFCo[1][1] + FrRadOut[1] + WaMoRa - Min.x) / GrSiSo + 1;
  *PnymaxFr = (RoSFCo[1][2] + FrRadOut[1] + WaMoRa - Min.y) / GrSiSo + 1;
  *PnzmaxFr = (RoSFCo[1][3] + FrRadOut[1] + WaMoRa - Min.z) / GrSiSo + 1;

/* Get the extremes of the fragment on the grid */
  for (iat=1;iat<=FrAtNu;iat++) {
    nxlow = (RoSFCo[iat][1] - FrRadOut[iat] - WaMoRa - Min.x) / GrSiSo + 1;
    nylow = (RoSFCo[iat][2] - FrRadOut[iat] - WaMoRa - Min.y) / GrSiSo + 1;
    nzlow = (RoSFCo[iat][3] - FrRadOut[iat] - WaMoRa - Min.z) / GrSiSo + 1;
    nxhi = (RoSFCo[iat][1] + FrRadOut[iat] + WaMoRa - Min.x) / GrSiSo + 1;
    nyhi = (RoSFCo[iat][2] + FrRadOut[iat] + WaMoRa - Min.y) / GrSiSo + 1;
    nzhi = (RoSFCo[iat][3] + FrRadOut[iat] + WaMoRa - Min.z) / GrSiSo + 1;
    *PnxminFr = (nxlow < *PnxminFr ) ? nxlow : *PnxminFr;
    *PnyminFr = (nylow < *PnyminFr ) ? nylow : *PnyminFr;
    *PnzminFr = (nzlow < *PnzminFr ) ? nzlow : *PnzminFr;
    *PnxmaxFr = (nxhi > *PnxmaxFr ) ? nxhi : *PnxmaxFr;
    *PnymaxFr = (nyhi > *PnymaxFr ) ? nyhi : *PnymaxFr;
    *PnzmaxFr = (nzhi > *PnzmaxFr ) ? nzhi : *PnzmaxFr;
  }

  *PFrOut = 0;
/* *PFrOut = 0  ---->  fragment completely contained in the receptor box
   *PFrOut = 1  ---->  fragment partially contained in the receptor box
   *PFrOut = 2  ---->  fragment completely out of the receptor box  */
  if ( (*PnxminFr < 1 && *PnxmaxFr < 1) ||
       (*PnxminFr > NGridx && *PnxmaxFr > NGridx) ||
       (*PnyminFr < 1 && *PnymaxFr < 1) ||
       (*PnyminFr > NGridy && *PnymaxFr > NGridy) ||
       (*PnzminFr < 1 && *PnzmaxFr < 1) ||
       (*PnzminFr > NGridz && *PnzmaxFr > NGridz) ){
    *PFrOut = 2;
    //std::cout << "fragment outside of the grid box" << std::endl;
  }
  else if ( *PnxminFr < 1 || *PnyminFr < 1 || *PnzminFr < 1 ||
            *PnxmaxFr > NGridx || *PnymaxFr > NGridy || *PnzmaxFr > NGridz ){
    *PFrOut = 1;
    //std::cout << "fragment partially outside of the grid box" << std::endl;
  }
  //else {
  //  std::cout << "fragment inside of the grid box" << std::endl;
  //}

  if (iat == FrAtNu+1 )
    return 1;
  else
    return 0;
}

int get_Rec_neigh(int ReAtNu,int FrAtNu,double **dist2,double **dist,
                  double *ReRad,double *FrRad,double *RePaCh,double WaMoRa,
                  int *nsurf_re,int *PNNeigh1,int *NeighList1,int *PNNeigh2,
                  int *NeighList2,int *PNNeigh3,int *NeighList3)
/*##########################################
Get lists of rec atoms at different distances (3 neighbour lists)
###########################################*/

/*##########################################
int ReAtNu -------------- Tot # rec atoms
int FrAtNu -------------- Tot # frag atoms
double **dist2 ----------- Squared interatomic rec-frag distances
double **dist ------------ Frag-rec interatomic distances
double *ReRad ----------- Rec charge radii (=vdW radii apart "enclosed" H)
double *FrRad ----------- Frag charge radii (=vdW radii apart "enclosed" H)
double *RePaCh ----------- Rec partial charges
double WaMoRa ----------- Radius of the water molecule
int *nsurf_re ----------- nsurf_re[n] = amount of SAS1 surface points
                          generated by rec atom n
int *PNNeigh1 ----------- Amount of rec atoms closer than 2*WaMoRa
                          to the fragment
int *NeighList1 --------- NeighList1[1->NNeigh1] = rec atom # closer
                          than 2*WaMoRa to the fragment
int *PNNeigh2 ----------- Amount of rec atoms closer than 3*WaMoRa
                          to the fragment
int *NeighList2 --------- NeighList2[1->NNeigh2] = rec atom # closer
                          than 3*WaMoRa to the fragment
int *PNNeigh3 ----------- Amount of rec atoms falling at least once
                          in the cutoff for non-bonded interactions
int *NeighList3 --------- NeighList3[1->NNeigh3] = rec atom # falling at least
                          once in the cutoff for non-bonded interactions
###########################################*/

{
  int iat,jat;
  double WaMoRa2,WaMoRa3;
  unsigned char *flag1,*flag2,*flag3;

/* flag tells us if a receptor atom has already been included in the
   list ('i') or not ('e') */
  flag1 = cvector(1,ReAtNu);
  flag2 = cvector(1,ReAtNu);
  flag3 = cvector(1,ReAtNu);
  for (jat=1;jat<=ReAtNu;jat++) {
    flag1[jat] = 'e';
    flag2[jat] = 'e';
    flag3[jat] = 'e';
  }

/* Creation of the 3 Neighbour Lists */
  WaMoRa2 = WaMoRa * 2.;
  WaMoRa3 = WaMoRa * 5.;
  *PNNeigh1 = 0;
  *PNNeigh2 = 0;
  *PNNeigh3 = 0;
  for (iat=1;iat<=FrAtNu;iat++) {
    for (jat=1;jat<=ReAtNu;jat++) {
      if (dist2[iat][jat] > 0.) {
        dist[iat][jat] = sqrt(dist2[iat][jat]);
        if (flag3[jat] == 'e' && RePaCh[jat] != 0.) {
          NeighList3[++(*PNNeigh3)] = jat;
          flag3[jat] = 'i';
        }
        if (nsurf_re[jat] > 0) {
          if (flag1[jat] == 'e' &&
            dist[iat][jat] < ReRad[jat] + FrRad[iat] + WaMoRa2) {
            NeighList1[++(*PNNeigh1)] = jat;
            flag1[jat] = 'i';
          }
          if (flag2[jat] == 'e' &&
              dist[iat][jat] < ReRad[jat] + FrRad[iat] + WaMoRa3) {
            NeighList2[++(*PNNeigh2)] = jat;
            flag2[jat] = 'i';
          }
        }
      }
    }
  }

  free_cvector(flag1,1,ReAtNu);
  free_cvector(flag2,1,ReAtNu);
  free_cvector(flag3,1,ReAtNu);

  if (iat == FrAtNu+1 )
    return 1;
  else
    return 0;
}

int Mov_surf(int Nsurfpt_fr,struct point *surfpt_fr_orig,double **FrCoor,
             double *FrMinC_orig,double *FrMaxC_orig,double Tr[4],double U1[4][4],
             double U2[4][4],struct point *surfpt_fr,double *FrMinC,
             double *FrMaxC)
/*##########################################
Move the frag SAS1 from FrCoor to RoSFCo
###########################################*/

/*##########################################
int Nsurfpt_fr ---------- Tot # of points over the frag SAS1
struct point *surfpt_fr_orig - Coor of points over frag SAS1 (relative to
                               FrCoor coordinates)
double **FrCoor ---------- Frag coordinates in the original location
double *FrMinC_orig ------ Min (along x,y,z) of FrCoor
double *FrMaxC_orig ------ Max (along x,y,z) of FrCoor
double Tr[4] ------------ Translation vector to superimpose the first atom of
                          FrCoor with the first of RoSFCo
double U1[4][4] --------- Rotation matrix around the axis passing by the 1st atom
                          of FrCoor and perpendicular to the plane formed by the
                          vector joining the 1st atom and the 2nd atom of FrCoor
                          and the vector joining the 1st atom and the 2nd atom of
                          RoSFCo. The rotation angle is such that it superimpose
                          the 2nd atom of RoSFCo with the 2nd atom of FrCoor
double U2[4][4] --------- Rotation matrix around the axis joining the 1st atom and
                          the 2nd atom of RoSFCo in order to superimpose
                          the 3rd atom of RoSFCo with the 3rd atom of FrCoor
struct point *surfpt_fr - Coor of points over frag SAS1 (relative to RoSFCo)
double FrMinC[4] --------- Min (along x,y,z) of RoSFCo
double FrMaxC[4] --------- Max (along x,y,z) of RoSFCo
###########################################*/
{
  int isph;
  double x_tr,y_tr,z_tr,x_r1,y_r1,z_r1,x_r2,y_r2,z_r2;

  for (isph=1;isph<=Nsurfpt_fr;isph++) {

/* Translate the point */
    x_tr = surfpt_fr_orig[isph].x - FrCoor[1][1];
    y_tr = surfpt_fr_orig[isph].y - FrCoor[1][2];
    z_tr = surfpt_fr_orig[isph].z - FrCoor[1][3];

/* Rotate the point with U1 */
    x_r1 = U1[1][1] * x_tr + U1[1][2] * y_tr + U1[1][3] * z_tr;
    y_r1 = U1[2][1] * x_tr + U1[2][2] * y_tr + U1[2][3] * z_tr;
    z_r1 = U1[3][1] * x_tr + U1[3][2] * y_tr + U1[3][3] * z_tr;

/* Rotate the point with U2 */
    x_r2 = U2[1][1]*x_r1 + U2[1][2]*y_r1 + U2[1][3]*z_r1;
    y_r2 = U2[2][1]*x_r1 + U2[2][2]*y_r1 + U2[2][3]*z_r1;
    z_r2 = U2[3][1]*x_r1 + U2[3][2]*y_r1 + U2[3][3]*z_r1;

    surfpt_fr[isph].x = x_r2 + Tr[1] + FrCoor[1][1];
    surfpt_fr[isph].y = y_r2 + Tr[2] + FrCoor[1][2];
    surfpt_fr[isph].z = z_r2 + Tr[3] + FrCoor[1][3];

 }

/* Translate min */
  x_tr = FrMinC_orig[1] - FrCoor[1][1];
  y_tr = FrMinC_orig[2] - FrCoor[1][2];
  z_tr = FrMinC_orig[3] - FrCoor[1][3];

/* Rotate min with U1 */
  x_r1 = U1[1][1] * x_tr + U1[1][2] * y_tr + U1[1][3] * z_tr;
  y_r1 = U1[2][1] * x_tr + U1[2][2] * y_tr + U1[2][3] * z_tr;
  z_r1 = U1[3][1] * x_tr + U1[3][2] * y_tr + U1[3][3] * z_tr;

/* Rotate min with U2 */
  x_r2 = U2[1][1]*x_r1 + U2[1][2]*y_r1 + U2[1][3]*z_r1;
  y_r2 = U2[2][1]*x_r1 + U2[2][2]*y_r1 + U2[2][3]*z_r1;
  z_r2 = U2[3][1]*x_r1 + U2[3][2]*y_r1 + U2[3][3]*z_r1;

  FrMinC[1] = x_r2 + Tr[1] + FrCoor[1][1];
  FrMinC[2] = y_r2 + Tr[2] + FrCoor[1][2];
  FrMinC[3] = z_r2 + Tr[3] + FrCoor[1][3];

/* Translate max */
  x_tr = FrMaxC_orig[1] - FrCoor[1][1];
  y_tr = FrMaxC_orig[2] - FrCoor[1][2];
  z_tr = FrMaxC_orig[3] - FrCoor[1][3];

/* Rotate max with U1 */
  x_r1 = U1[1][1] * x_tr + U1[1][2] * y_tr + U1[1][3] * z_tr;
  y_r1 = U1[2][1] * x_tr + U1[2][2] * y_tr + U1[2][3] * z_tr;
  z_r1 = U1[3][1] * x_tr + U1[3][2] * y_tr + U1[3][3] * z_tr;

/* Rotate max with U2 */
  x_r2 = U2[1][1]*x_r1 + U2[1][2]*y_r1 + U2[1][3]*z_r1;
  y_r2 = U2[2][1]*x_r1 + U2[2][2]*y_r1 + U2[2][3]*z_r1;
  z_r2 = U2[3][1]*x_r1 + U2[3][2]*y_r1 + U2[3][3]*z_r1;

  FrMaxC[1] = x_r2 + Tr[1] + FrCoor[1][1];
  FrMaxC[2] = y_r2 + Tr[2] + FrCoor[1][2];
  FrMaxC[3] = z_r2 + Tr[3] + FrCoor[1][3];

  if (isph == Nsurfpt_fr+1 )
    return 1;
  else
    return 0;
}

int join_surf(double **ReCoor,double *ReRadOut2,struct point *surfpt_re,
              int *nsurf_re,int *pointsrf_re,int FrAtNu,double **RoSFCo,
              double *FrRadOut2,struct point *surfpt_fr,int *nsurf_fr,
              int *pointsrf_fr,int NNeigh,int *NeighList,int *PNsurfpt_ex,
              struct point *surfpt_ex)
/*##########################################
join the SAS of the rec withe SAS of the frag (relative to RoSFCo)
and get the resulting SAS of the complex
###########################################*/

/*##########################################
double **ReCoor ---------- Rec Coordinates
double *ReRadOut2 ------- (Rec charge radii + WaMoRa)^2
struct point *surfpt_re - Coor of points over rec SAS1
int *nsurf_re ----------- nsurf_re[n] = amount of SAS1 surface points
                          generated by rec atom n
int *pointsrf_re -------- pointsrf_re[n] = first rec SAS1 point (in the
                          list surfpt_re) that is generated by rec atom n
int FrAtNu -------------- Tot # frag atoms
double **RoSFCo ---------- Frag coordinates in the seeded conformation
double *FrRadOut2 ------- (Frag charge radii + WaMoRa)^2
struct point *surfpt_fr - Coor of points over frag SAS1 (relative to RoSFCo)
int *nsurf_fr ----------- nsurf_fr[n] = amount of SAS1 surface points
                          generated by frag atom n
int *pointsrf_fr -------- pointsrf_fr[n] = first frag SAS1 point (in the
                          list surfpt_fr) that is generated by frag atom n
int NNeigh  ------------- Amount of rec atoms closer than 3*WaMoRa
                          to the fragment
int *NeighList  --------- NeighList[1->NNeigh] = rec atom # closer
                          than 3*WaMoRa to the fragment
int *PNsurfpt_ex -------- Tot # of SAS1 generated by the frag and
                          by those rec atoms that are at a
                          distance < 2*WaMoRa from at least 1 frag atom
struct point *surfpt_ex - Coor of points over SAS1 generated by the frag and
                          by those rec atoms that are at a distance < 2*WaMoRa
                          from at least 1 frag atom
###########################################*/
{
  int iat,jat,isph;
  double d2;

  *PNsurfpt_ex = 0;

/* Check which surf grid point of the SAS of the receptor neighbours fall
   inside the SAS of the fragment and exclude them */
  for (iat=1;iat<=NNeigh;iat++) {
    for (isph=pointsrf_re[NeighList[iat]];
         isph<=pointsrf_re[NeighList[iat]]+
         nsurf_re[NeighList[iat]] - 1 ; isph++) {
      for (jat=1;jat<=FrAtNu;jat++) {
        d2 = (surfpt_re[isph].x - RoSFCo[jat][1])*
             (surfpt_re[isph].x - RoSFCo[jat][1])+
             (surfpt_re[isph].y - RoSFCo[jat][2])*
             (surfpt_re[isph].y - RoSFCo[jat][2])+
             (surfpt_re[isph].z - RoSFCo[jat][3])*
             (surfpt_re[isph].z - RoSFCo[jat][3]);
        if (d2 < FrRadOut2[jat])
          goto newpoint;
      }

/* if get here, sphere point has survived the neighbors, and is accepted
   as a Shrake and Rupley surface point */
      pt_eq_pt(&surfpt_ex[++(*PNsurfpt_ex)],surfpt_re[isph]);

newpoint:
      continue;
    }
  }

/* Check which surf grid point of the SAS of the fragment fall inside the
   SAS of the receptor neighbours and exclude them */
  for (iat=1;iat<=FrAtNu;iat++) {
    for (isph=pointsrf_fr[iat];isph<=pointsrf_fr[iat] +
         nsurf_fr[iat] - 1 ; isph++) {
      for (jat=1;jat<=NNeigh;jat++) {
        d2 = (surfpt_fr[isph].x - ReCoor[NeighList[jat]][1])*
             (surfpt_fr[isph].x - ReCoor[NeighList[jat]][1])+
             (surfpt_fr[isph].y - ReCoor[NeighList[jat]][2])*
             (surfpt_fr[isph].y - ReCoor[NeighList[jat]][2])+
             (surfpt_fr[isph].z - ReCoor[NeighList[jat]][3])*
             (surfpt_fr[isph].z - ReCoor[NeighList[jat]][3]);
        if (d2 < ReRadOut2[NeighList[jat]])
          goto newpoint2;
      }

/* if get here, sphere point has survived the neighbors, and is accepted
   as a Shrake and Rupley surface point */
      pt_eq_pt(&surfpt_ex[++(*PNsurfpt_ex)],surfpt_fr[isph]);

newpoint2:
      continue;
    }
  }

  if (iat == FrAtNu+1 )
    return 1;
  else
    return 0;
}

int SAS_Volume_Fr(int ExFrAtNu,double **ExRoSFCo,double *ExFrRadOut,
                  double *ExFrRadOut2,struct point Min,
                  double GrSiSo,int NStartGridx,int NStartGridy,
                  int NStartGridz,int NGridx,int NGridy,int NGridz,
                  char ***FrGridMat,char ***GridMat,int FrOut)
/*##########################################
Get the volume enclosed by the SAS of the seeded frag
and of the neighbour rec atoms
###########################################*/

/*##########################################
int ExFrAtNu ------------ FrAtNu + NNeigh1
double **ExRoSFCo -------- Coor of the frag and of those rec atoms that are at a
                          distance < 2*WaMoRa from at least 1 frag atom
double *ExFrRadOut ------ Charge radii + WaMoRa of the frag and of those
                          rec atoms that are at a distance < 2*WaMoRa from
                          at least 1 frag atom
struct point Min -------- Min coor of the grid box
double GrSiSo ----------- Size of the 3D grid used for cont. electrostatics
int NStartGridx --------- First grid point along x occupied by the frag
int NStartGridy --------- First grid point along y occupied by the frag
int NStartGridz --------- First grid point along z occupied by the frag
int NGridx -------------- Last grid point along x occupied by the frag
int NGridy -------------- Last grid point along y occupied by the frag
int NGridz -------------- Last grid point along z occupied by the frag
char ***FrGridMat ------- Small submatrix of GridMat around the frag telling the
                          volume occupied by the frag in the bound conformation
char ***GridMat --------- Matrix telling if a grid point is occupied by the
                          rec (o), empty (e), or if it belongs to the interface
                          between SAS and MS (s)
int FrOut --------------- Flag telling the position of the frag respect
                          to the elec grid box:
                          0 = frag completely contained in the grid box
                          1 = fragment partially contained in the grid box
                          2 = fragment completely out of the grid box
###########################################*/
{
  int iat,ix,iy,iz,ixmin,iymin,izmin,ixmax,iymax,izmax;
  double xtemp,x2temp,ytemp,xy2temp,ztemp,r2;

/* Calculate grid points occupied by volume enclosed in SAS */
  if ( FrOut == 0 ) {
    for (iat=1;iat<=ExFrAtNu;iat++) {
      ixmin = (ExRoSFCo[iat][1] - ExFrRadOut[iat] - Min.x) / GrSiSo + 1;
      iymin = (ExRoSFCo[iat][2] - ExFrRadOut[iat] - Min.y) / GrSiSo + 1;
      izmin = (ExRoSFCo[iat][3] - ExFrRadOut[iat] - Min.z) / GrSiSo + 1;
      ixmax = (ExRoSFCo[iat][1] + ExFrRadOut[iat] - Min.x) / GrSiSo + 1;
      iymax = (ExRoSFCo[iat][2] + ExFrRadOut[iat] - Min.y) / GrSiSo + 1;
      izmax = (ExRoSFCo[iat][3] + ExFrRadOut[iat] - Min.z) / GrSiSo + 1;
      ixmin = (ixmin > NStartGridx) ? ixmin : NStartGridx;
      iymin = (iymin > NStartGridy) ? iymin : NStartGridy;
      izmin = (izmin > NStartGridz) ? izmin : NStartGridz;
      ixmax = (ixmax < NGridx) ? ixmax : NGridx;
      iymax = (iymax < NGridy) ? iymax : NGridy;
      izmax = (izmax < NGridz) ? izmax : NGridz;

      xtemp = GrSiSo * (ixmin - 1.5) + Min.x - ExRoSFCo[iat][1];
      for (ix=ixmin;ix<=ixmax;ix++) {
        xtemp += GrSiSo;
        x2temp = xtemp*xtemp;
        if (ExFrRadOut2[iat] > x2temp) {
          ytemp = GrSiSo * (iymin - 1.5) + Min.y - ExRoSFCo[iat][2];
          for (iy=iymin;iy<=iymax;iy++) {
            ytemp += GrSiSo;
            xy2temp = ytemp*ytemp + x2temp;
            if (ExFrRadOut2[iat] > xy2temp) {
              ztemp = GrSiSo * (izmin - 1.5) + Min.z - ExRoSFCo[iat][3];
              for (iz=izmin;iz<=izmax;iz++) {
                ztemp += GrSiSo;
                if (FrGridMat[ix][iy][iz] != 'o' &&
                    GridMat[ix][iy][iz] != 'o') {
                  r2 = ztemp * ztemp + xy2temp;
                  if (ExFrRadOut2[iat] > r2)
                    FrGridMat[ix][iy][iz] = 'o';
                }
              }
            }
          }
        }
      }
    }
  }
  else if ( FrOut == 1 ) {
    for (iat=1;iat<=ExFrAtNu;iat++) {
      ixmin = (ExRoSFCo[iat][1] - ExFrRadOut[iat] - Min.x) / GrSiSo + 1;
      iymin = (ExRoSFCo[iat][2] - ExFrRadOut[iat] - Min.y) / GrSiSo + 1;
      izmin = (ExRoSFCo[iat][3] - ExFrRadOut[iat] - Min.z) / GrSiSo + 1;
      ixmax = (ExRoSFCo[iat][1] + ExFrRadOut[iat] - Min.x) / GrSiSo + 1;
      iymax = (ExRoSFCo[iat][2] + ExFrRadOut[iat] - Min.y) / GrSiSo + 1;
      izmax = (ExRoSFCo[iat][3] + ExFrRadOut[iat] - Min.z) / GrSiSo + 1;
      ixmin = (ixmin > NStartGridx) ? ixmin : NStartGridx;
      iymin = (iymin > NStartGridy) ? iymin : NStartGridy;
      izmin = (izmin > NStartGridz) ? izmin : NStartGridz;
      ixmax = (ixmax < NGridx) ? ixmax : NGridx;
      iymax = (iymax < NGridy) ? iymax : NGridy;
      izmax = (izmax < NGridz) ? izmax : NGridz;

      xtemp = GrSiSo * (ixmin - 1.5) + Min.x - ExRoSFCo[iat][1];
      for (ix=ixmin;ix<=ixmax;ix++) {
        xtemp += GrSiSo;
        x2temp = xtemp*xtemp;
        if (ExFrRadOut2[iat] > x2temp) {
          ytemp = GrSiSo * (iymin - 1.5) + Min.y - ExRoSFCo[iat][2];
          for (iy=iymin;iy<=iymax;iy++) {
            ytemp += GrSiSo;
            xy2temp = ytemp*ytemp + x2temp;
            if (ExFrRadOut2[iat] > xy2temp) {
              ztemp = GrSiSo * (izmin - 1.5) + Min.z - ExRoSFCo[iat][3];
              for (iz=izmin;iz<=izmax;iz++) {
                ztemp += GrSiSo;
                if (FrGridMat[ix][iy][iz] != 'o') {
                  r2 = ztemp * ztemp + xy2temp;
                  if (ExFrRadOut2[iat] > r2)
                    FrGridMat[ix][iy][iz] = 'o';
                }
              }
            }
          }
        }
      }
    }
  }
  else
    { /* exception handling */
      iat = 0;
    }
  if (iat == ExFrAtNu+1 )
    return 1;
  else
    return 0;
}

int Excl_Grid_Fr(struct point Min,double WaMoRa,double GrSiSo,
                 int nxminFr,int nyminFr,int nzminFr,
                 int nxmaxFr,int nymaxFr,int nzmaxFr,
                 char ***FrGridMat,int Nsurfpt,struct point *surfpt)
/*########################################################
Place a sphere (WaMoRa) over each SAS frag point (surfpt) and set
to empty (FrGridMat = 'e') all the grid points occupied by the sphere
##########################################################*/

/*##########################################
struct point Min -------- Min coor of the grid box
double WaMoRa ----------- Radius of the water molecule
double GrSiSo ----------- Size of the 3D grid used for cont. electrostatics
int nxminFr ------------- grid point (along x) where the frag starts
int nyminFr ------------- grid point (along y) where the frag starts
int nzminFr ------------- grid point (along z) where the frag starts
int nxmaxFr ------------- grid point (along x) where the frag ends
int nymaxFr ------------- grid point (along y) where the frag ends
int nzmaxFr ------------- grid point (along z) where the frag ends
char ***FrGridMat ------- Small submatrix of GridMat around the frag telling the
                          volume occupied by the frag in the bound conformation
int Nsurfpt ------------- Tot # of points over SAS
struct point *surfpt ---- Coor of points over SAS
###########################################*/
{
  int i,ix,iy,iz,ixmin,iymin,izmin,ixmax,iymax,izmax;
  double WaMoRa2,xtemp,x2temp,ytemp,xy2temp,ztemp,r2;

  WaMoRa2 = WaMoRa * WaMoRa;

/* Loop over S&R surface points, place a probe sphere over each of them
   and set to 's' all the 3D grid point covered by it */

  for (i=1;i<=Nsurfpt;i++) {

/* Calculate the extremes, in the grid frame, of the cube containing the
   probe sphere. They are integer! */

    ixmin = (surfpt[i].x - WaMoRa - Min.x) / GrSiSo + 1;
    iymin = (surfpt[i].y - WaMoRa - Min.y) / GrSiSo + 1;
    izmin = (surfpt[i].z - WaMoRa - Min.z) / GrSiSo + 1;
    ixmax = (surfpt[i].x + WaMoRa - Min.x) / GrSiSo + 1;
    iymax = (surfpt[i].y + WaMoRa - Min.y) / GrSiSo + 1;
    izmax = (surfpt[i].z + WaMoRa - Min.z) / GrSiSo + 1;
    ixmin = (ixmin > nxminFr) ? ixmin : nxminFr;
    iymin = (iymin > nyminFr) ? iymin : nyminFr;
    izmin = (izmin > nzminFr) ? izmin : nzminFr;
    ixmax = (ixmax < nxmaxFr) ? ixmax : nxmaxFr;
    iymax = (iymax < nymaxFr) ? iymax : nymaxFr;
    izmax = (izmax < nzmaxFr) ? izmax : nzmaxFr;

    if (ixmin <= ixmax && iymin <= iymax && izmin <= izmax) {

/* xtemp,ytemp,ztemp are cartesian coordinates of the grid pt ix,iy,iz,
   in a frame with the origin in the suface point surfpt[i] */

      xtemp = GrSiSo * (ixmin - 1.5) + Min.x - surfpt[i].x;
      for (ix=ixmin;ix<=ixmax;ix++) {
        xtemp += GrSiSo;
        x2temp = xtemp*xtemp;
        if (WaMoRa2 > x2temp) {
          ytemp = GrSiSo * (iymin - 1.5) + Min.y - surfpt[i].y;
          for (iy=iymin;iy<=iymax;iy++) {
            ytemp += GrSiSo;
            xy2temp = ytemp*ytemp + x2temp;

/*  Check if we are already out of the sphere */

            if (WaMoRa2 > xy2temp) {
              ztemp = GrSiSo * (izmin - 1.5) + Min.z - surfpt[i].z;
              for (iz=izmin;iz<=izmax;iz++) {
                ztemp += GrSiSo;
                if (FrGridMat[ix][iy][iz] == 'o') {
                  r2 = ztemp * ztemp + xy2temp;

/* Check if our grid point is inside the sphere. If yes change FrGridMat */

                  if (WaMoRa2 > r2)
                    FrGridMat[ix][iy][iz] = 's';
                }
              }
            }
          }
        }
      }
    }
  }

  if (i == Nsurfpt+1 )
    return 1;
  else
    return 0;
}

int Rot_Tran(int FrAtNu,double **FrCoor,double **RoSFCo,double Tr[4],
             double U1[4][4],double U2[4][4])
/*########################################################
Get the geometric transformations (1 translation and 2 rotations)
necessary to go from FrCoor to RoSFCo
##########################################################*/

/*##########################################
int FrAtNu -------------- Tot # frag atoms
double **FrCoor ---------- Frag coordinates in the original location
double **RoSFCo ---------- Frag coordinates in the seeded conformation
double Tr[4] ------------ Translation vector to superimpose the first atom of
                          FrCoor with the first of RoSFCo
double U1[4][4] --------- Rotation matrix around the axis passing by the 1st atom
                          of FrCoor and perpendicular to the plane formed by the
                          vector joining the 1st atom and the 2nd atom of FrCoor
                          and the vector joining the 1st atom and the 2nd atom of
                          RoSFCo. The rotation angle is such that it superimpose
                          the 2nd atom of RoSFCo with the 2nd atom of FrCoor
double U2[4][4] --------- Rotation matrix around the axis joining the 1st atom and
                          the 2nd atom of RoSFCo in order to superimpose
                          the 3rd atom of RoSFCo with the 3rd atom of FrCoor
###########################################*/
{
  int i,j,k,same;
  double Axis[4],phi,cosphi,sinphi,v[4],w[4],norm,costh,Axis2[4];
  double epsilon = 10000*std::numeric_limits<double>::epsilon();

/* Check if the coordinates are exactly the same */
  same = 1;
  for (i=1;i<=3;i++)
    for (j=1;j<=FrAtNu;j++)
      if (RoSFCo[j][i] != FrCoor[j][i] ) {
        same = 0;
        goto out;
      }

out:
  if (same == 1) {
    for (j=1;j<=3;j++)
      Tr[j]=0.0;
    for (j=1;j<=3;j++) {
      for (k=1;k<=3;k++) {
        if (j==k) {
          U1[j][k]=1.0;
          U2[j][k]=1.0;
        }
        else {
          U1[j][k]=0.0;
          U2[j][k]=0.0;
        }
      }
    }
  }

  else {
/* Get the translation vector (Tr) to superpose the atoms 1 */
  for (i=1;i<=3;i++)
    Tr[i] = RoSFCo[1][i] - FrCoor[1][i];

/* Get U1: the rotation matrix around the axis passing by the 1st atom
   of FrCoor and perpendicular to the plane formed by the vector joining
   the 1st atom and the 2nd atom of FrCoor and the vector joining the 1st
   atom and the 2nd atom of RoSFCo. The rotation angle is such that it
   superimpose the 2nd atom of RoSFCo with the 2nd atom of FrCoor*/
  for (i=1;i<=3;i++)
    v[i] = FrCoor[2][i] - FrCoor[1][i];

  for (i=1;i<=3;i++)
    w[i] = RoSFCo[2][i] - RoSFCo[1][i];

  Axis[1] = v[2]*w[3] - v[3]*w[2];
  Axis[2] = v[3]*w[1] - v[1]*w[3];
  Axis[3] = v[1]*w[2] - v[2]*w[1];

  norm = sqrt(Axis[1]*Axis[1] + Axis[2]*Axis[2] + Axis[3]*Axis[3]);

/* Check degeneracy (if v and w are (anti)parallel) and act consequently */
  //std::cout << "U1 norm " << norm << std::endl;
  //if (norm == 0.)
  if (fabs(norm) < epsilon) {
    Axis[1] = 0.;
    Axis[2] = -v[3];
    Axis[3] = v[2];
    norm = sqrt(Axis[1]*Axis[1] + Axis[2]*Axis[2] + Axis[3]*Axis[3]);
  }
  //if (norm == 0.)
  if (fabs(norm) < epsilon) {
    Axis[1] = -v[3];
    Axis[2] = 0.;
    Axis[3] = v[1];
    norm = sqrt(Axis[1]*Axis[1] + Axis[2]*Axis[2] + Axis[3]*Axis[3]);
  }
  //if (norm == 0.)
  if (fabs(norm) < epsilon) {
    Axis[1] = -v[2];
    Axis[2] = v[1];
    Axis[3] = 0.;
    norm = sqrt(Axis[1]*Axis[1] + Axis[2]*Axis[2] + Axis[3]*Axis[3]);
  }
  //std::cout << "U1 norm " << norm << std::endl;
  for (i=1;i<=3;i++)
    Axis[i] /= norm;

  norm = sqrt((v[1]*v[1] + v[2]*v[2] + v[3]*v[3])*
               (w[1]*w[1] + w[2]*w[2] + w[3]*w[3]));
  cosphi = (v[1]*w[1] + v[2]*w[2] + v[3]*w[3])/norm;
  cosphi = (cosphi < 1.0000000000) ? cosphi : 1.0000000000;
  cosphi = (cosphi > -1.0000000000) ? cosphi : -1.0000000000;
  phi = acos(cosphi);

  sinphi = sin(phi);
  //clangini debug start
  //std::cout << "cosphi = " << std::setprecision(20) << cosphi << std::endl;
  //std::cout << "phi = " << std::setprecision(20) << phi << std::endl;
  //std::cout << "sinphi = " << std::setprecision(20) << sinphi << std::endl;
  // clangini debug end
  //clangini debug start
  // if (cosphi >= 1){
  //   cosphi = 1.;
  //   phi = 0. ;
  //   sinphi = 0. ;
  // } else if (cosphi <= -1){
  //   cosphi = -1.;
  //   phi = M_PI;
  //   sinphi = 0. ;
  // } else{
  //   phi = acos(cosphi);
  //   sinphi = sin(phi);
  // }
  //
  // std::cout << "cosphi = " << std::setprecision(20) << cosphi << std::endl;
  // std::cout << "phi = " << std::setprecision(20) << phi << std::endl;
  // std::cout << "sinphi = " << std::setprecision(20) << sinphi << std::endl;
  // clangini debug end


  for (i=1;i<=3;i++) {
    for (j=1;j<=3;j++)
      v[j] = 0.;
    v[i] = 1.;
    costh = v[i] * Axis[i];
    for (j=1;j<=3;j++)
      v[j] = v[j] - costh*Axis[j];

    w[1] = Axis[2]*v[3] - Axis[3]*v[2];
    w[2] = Axis[3]*v[1] - Axis[1]*v[3];
    w[3] = Axis[1]*v[2] - Axis[2]*v[1];

    for (j=1;j<=3;j++)
      U1[i][j] = costh * Axis[j] + cosphi * v[j] - sinphi * w[j];
  }

/* Now rotate around the axis between 1 and 2 in order to superimpose atoms 3
   The rotation matrix will be U2 */
  for (i=1;i<=3;i++)
    Axis[i] = RoSFCo[2][i] - RoSFCo[1][i];
  norm = sqrt(Axis[1]*Axis[1] + Axis[2]*Axis[2] + Axis[3]*Axis[3]);
  for (i=1;i<=3;i++)
    Axis[i] /= norm;

  for (i=1;i<=3;i++)
    v[i] = U1[i][1] * (FrCoor[3][1] - FrCoor[1][1]) +
           U1[i][2] * (FrCoor[3][2] - FrCoor[1][2]) +
           U1[i][3] * (FrCoor[3][3] - FrCoor[1][3]);

  costh = v[1] * Axis[1] + v[2] * Axis[2] + v[3] * Axis[3];
  for (i=1;i<=3;i++)
    v[i] = v[i] - costh*Axis[i];

  for (i=1;i<=3;i++)
    w[i] = RoSFCo[3][i] - RoSFCo[1][i];
  costh = w[1] * Axis[1] + w[2] * Axis[2] + w[3] * Axis[3];
  for (i=1;i<=3;i++)
    w[i] = w[i] - costh*Axis[i];

  norm = sqrt((v[1]*v[1] + v[2]*v[2] + v[3]*v[3])*
               (w[1]*w[1] + w[2]*w[2] + w[3]*w[3]));
  cosphi = (v[1]*w[1] + v[2]*w[2] + v[3]*w[3])/norm;

  cosphi = (cosphi < 1.0000000000) ? cosphi : 1.0000000000;
  cosphi = (cosphi > -1.0000000000) ? cosphi : -1.0000000000;

  phi = acos(cosphi);

  sinphi = sin(phi);
  //clangini debug start
  //std::cout << "cosphi = " << std::setprecision(20) << cosphi << std::endl;
  //std::cout << "phi = " << std::setprecision(20) << phi << std::endl;
  //std::cout << "sinphi = " << std::setprecision(20) << sinphi << std::endl;
  // clangini debug end

  //clangini debug start
  // if (cosphi >= 0.9999){
  //   cosphi = 1.;
  //   phi = 0. ;
  //   sinphi = 0. ;
  // } else if (cosphi <= -0.9999){
  //   cosphi = -1.;
  //   phi = M_PI;
  //   sinphi = 0. ;
  // } else{
  //   phi = acos(cosphi);
  //   sinphi = sin(phi);
  // }
  //
  // std::cout << "cosphi = " << std::setprecision(20) << cosphi << std::endl;
  // std::cout << "phi = " << std::setprecision(20) << phi << std::endl;
  // std::cout << "sinphi = " << std::setprecision(20) << sinphi << std::endl;
  // clangini debug end


  Axis2[1] = v[2]*w[3] - v[3]*w[2];
  Axis2[2] = v[3]*w[1] - v[1]*w[3];
  Axis2[3] = v[1]*w[2] - v[2]*w[1];

  norm = sqrt(Axis2[1]*Axis2[1] + Axis2[2]*Axis2[2] + Axis2[3]*Axis2[3]);

  // std::cout << "Norm: " << norm << std::endl;
  // if (norm == 0.0) {
  //   Axis2[1]=Axis[1];
  //   Axis2[2]=Axis[2];
  //   Axis2[3]=Axis[3];
  //   norm=1.;
  // }
  //clangini debug start
  //for (int a = 1; a <=3; a++){
  //  std::cout << "Axis[" << a << "]: " << Axis[a]
  //            << "  Axis2[" << a << "]: " << Axis2[a] << std::endl;
  //}
  //std::cout << "Norm: " << norm << std::endl;
  //std::cout << "epsilon: " << 100*std::numeric_limits<double>::epsilon() << std::endl;
  //std::cout << "U2 norm " << norm << std::endl;
  if (fabs(norm) < epsilon) {
    Axis2[1]=Axis[1];
    Axis2[2]=Axis[2];
    Axis2[3]=Axis[3];
    norm=1.;
  }
  //std::cout << "U2 norm " << norm << std::endl;
  //std::cout << "Norm: " << norm << std::endl;
  //clangini debug end

  for (i=1;i<=3;i++)
    Axis2[i] /= norm;

  for (i=1;i<=3;i++) {
    for (j=1;j<=3;j++)
      v[j] = 0.;
    v[i] = 1.;
    costh = v[i] * Axis2[i];
    for (j=1;j<=3;j++)
      v[j] = v[j] - costh*Axis2[j];

    w[1] = Axis2[2]*v[3] - Axis2[3]*v[2];
    w[2] = Axis2[3]*v[1] - Axis2[1]*v[3];
    w[3] = Axis2[1]*v[2] - Axis2[2]*v[1];

    for (j=1;j<=3;j++)
      U2[i][j] = costh * Axis2[j] + cosphi * v[j] - sinphi * w[j];
  }
  }
  return 1;
}

int Get_Self_Vol_Re(int ReAtNu,double **ReCoor,int NFrNeigh,int *FrNeighList,
                    double *ReRad2,
                    double GrSiSo,double *XGrid,double *YGrid,double *ZGrid,
                    int NStartGridx,int NStartGridy,int NStartGridz,
                    int NGridx,int NGridy,int NGridz,
                    double UnitVol,char ***GridMat,double *SelfVol,
		                double *SelfVol_corrB,char *EmpCorrB)
/*##########################################
For rec atoms: Add to the integral of 1/r^4 resulting from
the isolated rec the contribution due to the presence of the frag

SelfVol has already been calculated for the isolated receptor. Here we add the
integral on the volume occupied by the fragment.
###########################################*/

/*##########################################
int ReAtNu -------------- Tot # atoms
double **ReCoor ---------- Coordinates
int NFrNeigh ------------ Amount of rec atoms falling at least once
                          in the cutoff for non-bonded interactions
int *FrNeighList -------- FrNeighList[1->NFrNeigh] = rec atom # falling at least
                          once in the cutoff for non-bonded interactions
double *ReRad2 ---------- (Rec charge radii)^2
double GrSiSo ----------- Size of the 3D grid used for cont. electrostatics
double *XGrid ----------- X coor of the grid points
double *YGrid ----------- Y coor of the grid points
double *ZGrid ----------- Z coor of the grid points
int NStartGridx --------- First grid point along x occupied by the frag
int NStartGridy --------- First grid point along y occupied by the frag
int NStartGridz --------- First grid point along z occupied by the frag
int NGridx -------------- Last grid point along x occupied by the frag
int NGridy -------------- Last grid point along y occupied by the frag
int NGridz -------------- Last grid point along z occupied by the frag
double UnitVol ---------- Volume of the grid element for cont. elec.
char ***GridMat --------- Small submatrix of GridMat around the frag telling the
                          volume occupied by the frag in the bound conformation
double *SelfVol --------- SelfVol[iat] = integral of 1/r^4 over
                          the rec and the frag volume for rec atom iat
###########################################*/
{
  int ix,iy,iz,ixf,iyf,izf,Neigh,*NeighList,iat,jat,filled,dolist;
  double UnitVol27,cutoff,cutoff2,cutoff2_grid,r2,*SelfVolTmp,*SelfVolTmp_corrB;

  cutoff = 5.;      /* cutoff between fine and coarse 3D grid */
  cutoff2 = cutoff * cutoff; /* 25.0 */
  cutoff2_grid = (cutoff+sqrt(3.)*GrSiSo)*(cutoff+sqrt(3.)*GrSiSo);
  UnitVol27 = UnitVol * 27.;

  NeighList=ivector(1,ReAtNu);
  SelfVolTmp=dvector(1,ReAtNu);
  SelfVolTmp_corrB=dvector(1,ReAtNu);
  for (iat=1;iat<=ReAtNu;iat++)
  {
    SelfVolTmp[iat]=0.0000000000000000;
    SelfVolTmp_corrB[iat]=0.0000000000000000;
  }

/* The grid points falling at a distance smaller than cutoff are accounted
as they are. The ones falling at a larger distance are grouped in cubes of
27 elements and are accounted according to the fact that the central grid
point or not.
 NeighList gives the list af atoms that are close to a 27-element cube */

/* Loop over the centers of the cubes of 27 elements */
  for (ix=NStartGridx+1;ix<=NGridx;ix+=3) {
    for (iy=NStartGridy+1;iy<=NGridy;iy+=3) {
      for (iz=NStartGridz+1;iz<=NGridz;iz+=3) {
        filled = 0;
        dolist = 0;
        if (GridMat[ix][iy][iz] == 'o') {
          filled = 1;
          dolist = 1;
        }
        else {
/* Loop inside the cubes of 27 elements to check if at least one is occupied */
          for (ixf=ix-1;ixf<=ix+1;ixf++) {
            for (iyf=iy-1;iyf<=iy+1;iyf++) {
              for (izf=iz-1;izf<=iz+1;izf++) {
                if (GridMat[ixf][iyf][izf] == 'o') {
                  dolist = 1;
                  goto do_neigh_list;
                }
              }
            }
          }
        }
do_neigh_list:
/* If come here it means that at least one point of the
27-element cube is occupied */
/* Now loop inside the cube and over the atoms and assign the contribution
to the integral of 1/r^4 */
        if (dolist) {
          Neigh = 0;
          for (iat=1;iat<=NFrNeigh;iat++) {
            r2 = (XGrid[ix]-ReCoor[FrNeighList[iat]][1])*
                 (XGrid[ix]-ReCoor[FrNeighList[iat]][1])+
                 (YGrid[iy]-ReCoor[FrNeighList[iat]][2])*
                 (YGrid[iy]-ReCoor[FrNeighList[iat]][2])+
                 (ZGrid[iz]-ReCoor[FrNeighList[iat]][3])*
                 (ZGrid[iz]-ReCoor[FrNeighList[iat]][3]);
            if ( r2 > cutoff2_grid ) {
              if (filled)
	      {
                SelfVolTmp[FrNeighList[iat]] += UnitVol27 / (r2 * r2);
		if (EmpCorrB[0]=='y')
		  SelfVolTmp_corrB[FrNeighList[iat]] += UnitVol27 / (r2 * r2 * sqrt(r2));
	      }
            }
            else if (r2 < cutoff2_grid && r2 > cutoff2) {
              if (filled)
	      {
                SelfVolTmp[FrNeighList[iat]] += UnitVol27 / (r2 * r2);
		if (EmpCorrB[0]=='y')
		  SelfVolTmp_corrB[FrNeighList[iat]] += UnitVol27 / (r2 * r2 * sqrt(r2));
	      }
              ++Neigh;
              NeighList[Neigh] = FrNeighList[iat];
            }
            else {
              ++Neigh;
              NeighList[Neigh] = FrNeighList[iat];
            }
          }
          for (ixf=ix-1;ixf<=ix+1;ixf++) {
            for (iyf=iy-1;iyf<=iy+1;iyf++) {
              for (izf=iz-1;izf<=iz+1;izf++) {
                if (GridMat[ixf][iyf][izf] == 'o') {
                  for (jat=1;jat<=Neigh;jat++) {
                    r2 = (XGrid[ixf]-ReCoor[NeighList[jat]][1]) *
                         (XGrid[ixf]-ReCoor[NeighList[jat]][1]) +
                         (YGrid[iyf]-ReCoor[NeighList[jat]][2]) *
                         (YGrid[iyf]-ReCoor[NeighList[jat]][2]) +
                         (ZGrid[izf]-ReCoor[NeighList[jat]][3]) *
                         (ZGrid[izf]-ReCoor[NeighList[jat]][3]);
                    if ( r2 < cutoff2 && r2 > ReRad2[NeighList[jat]] )
		    {
                      SelfVolTmp[NeighList[jat]] += UnitVol / (r2 * r2);
		      if (EmpCorrB[0]=='y')
		        SelfVolTmp_corrB[NeighList[jat]] += UnitVol / (r2 * r2 * sqrt(r2));
		    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  for (iat=1;iat<=NFrNeigh;iat++)
  {
    SelfVol[FrNeighList[iat]] += SelfVolTmp[FrNeighList[iat]];
    SelfVol_corrB[FrNeighList[iat]] += SelfVolTmp_corrB[FrNeighList[iat]];
  }

  free_dvector(SelfVolTmp,1,ReAtNu);
  free_dvector(SelfVolTmp_corrB,1,ReAtNu);
  free_ivector(NeighList,1,ReAtNu);

  if (ix > NGridx )
    return 1;
  else
    return 0;
}

int Get_Self_Vol_Fr(int FrAtNu,double **RoSFCo,double *FrPaCh,
                    double *FrRad2,double *FrRadOut,double *FrRadOut2,
                    double GrSiSo,double *XGrid,double *YGrid,double *ZGrid,
                    struct point Min,double UnitVol,int NGridx,int NGridy,
                    int NGridz,char ***GridMat,int nxminFr,int nyminFr,
                    int nzminFr,int nxmaxFr,int nymaxFr,int nzmaxFr,
                    char ***FrGridMat,int FrOut,int nxmin_big,int nymin_big,
                    int nzmin_big,int nxmax_big,int nymax_big,int nzmax_big,
                    double *SelfVol,double *SelfVol_corrB,char *EmpCorrB)
/*##########################################
For frag atoms: get the integral of 1/r^4 resulting from
the frag and the surrounding rec
###########################################*/

/*##########################################
int FrAtNu -------------- Tot # frag atoms
double **RoSFCo ---------- Frag coordinates in the seeded conformation
double *FrPaCh ----------- Frag partial charges
double *FrRad2 ---------- (Frag charge radii)^2
double *FrRadOut -------- Frag charge radii + WaMoRa
double *FrRadOut2 ------- (Frag charge radii + WaMoRa)^2
double GrSiSo ----------- Size of the 3D grid used for cont. electrostatics
double *XGrid ----------- X coor of the grid points
double *YGrid ----------- Y coor of the grid points
double *ZGrid ----------- Z coor of the grid points
struct point Min -------- Min coor of the grid box
double UnitVol ---------- Volume of the grid element for cont. elec.
int  NGridx ------------- Tot # of grid points along x
int  NGridy ------------- Tot # of grid points along y
int  NGridz ------------- Tot # of grid points along z
char ***GridMat --------- Matrix telling if a grid point is occupied by the
                          rec (o), empty (e), or if it belongs to the interface
                          between SAS and MS (s)
int nxminFr ------------- grid point (along x) where the frag starts
int nyminFr ------------- grid point (along y) where the frag starts
int nzminFr ------------- grid point (along z) where the frag starts
int nxmaxFr ------------- grid point (along x) where the frag ends
int nymaxFr ------------- grid point (along y) where the frag ends
int nzmaxFr ------------- grid point (along z) where the frag ends
char ***FrGridMat ------- Small submatrix of GridMat around the frag telling the
                          volume occupied by the frag in the bound conformation
int FrOut --------------- Flag telling the position of the frag respect
                          to the elec grid box:
                          0 = frag completely contained in the grid box
                          1 = fragment partially contained in the grid box
                          2 = fragment completely out of the grid box
int nxmin_big ----------- The smallest between nxminFr and 1
int nymin_big ----------- The smallest between nyminFr and 1
int nzmin_big ----------- The smallest between nzminFr and 1
int nxmax_big ----------- The biggest between nxmaxFr and NGridx
int nymax_big ----------- The biggest between nymaxFr and NGridy
int nzmax_big ----------- The biggest between nzmaxFr and NGridz
double *SelfVol --------- SelfVol[iat] = integral of 1/r^4 over the solute
                          volume for frag atom iat
###########################################*/
{
  int ix,iy,iz,ixc,iyc,izc,ixmincf,iymincf,izmincf,ixmaxcf,iymaxcf,izmaxcf,
      ixminrad,iyminrad,izminrad,ixmaxrad,iymaxrad,izmaxrad,boxL,boxradL,iat;
  double cutoff1,cutoff2,cutoff1sq,cutoff2sq,r2,r4,UnitVol27,UnitVol125,GrSiSo3;

  cutoff1 = 5.;      /* cutoff between fine and coarse 3D grid */
  cutoff2 = 12.;      /* cutoff between medium and coarse 3D grid */
/* The next condition is necessary to speed up the loops (less boundary
   checking if FrOut == 0)  */
  if (FrOut == 0) {
    cutoff1sq = cutoff1 * cutoff1;
    boxL = (cutoff1 + 0.00001) / GrSiSo + 1;
/* Integration with grid size GrSiSo */
/* #ifdef OMP */
/* #pragma omp parallel for default(none) private(ix,iy,iz,ixc,iyc,izc,ixmincf,iymincf,izmincf,ixmaxcf,iymaxcf,izmaxcf,boxradL,ixminrad,iyminrad,izminrad,ixmaxrad,iymaxrad,izmaxrad,r2,r4,EmpCorrB,nymin_big,nzmin_big,nxminFr,nxmaxFr,nymaxFr,nzmaxFr) shared(FrPaCh,SelfVol,SelfVol_corrB,FrAtNu,RoSFCo,Min,boxL,GrSiSo,nxmin_big,nxmax_big,nymax_big,XGrid,YGrid,ZGrid,FrRadOut,FrRad2,FrRadOut2,GridMat,UnitVol) */
/* #endif  */
    for (iat=1;iat<=FrAtNu;iat++) {
      if (FrPaCh[iat] != 0. ) {
        ixc = (RoSFCo[iat][1] - Min.x) / GrSiSo + 1;
        iyc = (RoSFCo[iat][2] - Min.y) / GrSiSo + 1;
        izc = (RoSFCo[iat][3] - Min.z) / GrSiSo + 1;
        ixmincf = ixc-boxL;
        iymincf = iyc-boxL;
        izmincf = izc-boxL;
        ixmaxcf = ixc+boxL;
        iymaxcf = iyc+boxL;
        izmaxcf = izc+boxL;
        boxradL = (FrRadOut[iat] + 0.00001) / GrSiSo + 1;
        ixminrad = ixc-boxradL;
        iyminrad = iyc-boxradL;
        izminrad = izc-boxradL;
        ixmaxrad = ixc+boxradL;
        iymaxrad = iyc+boxradL;
        izmaxrad = izc+boxradL;
        ixmincf = (ixmincf > nxmin_big) ? ixmincf : nxmin_big;
        iymincf = (iymincf > nymin_big) ? iymincf : nymin_big;
        izmincf = (izmincf > nzmin_big) ? izmincf : nzmin_big;
        ixmaxcf = (ixmaxcf < nxmax_big) ? ixmaxcf : nxmax_big;
        iymaxcf = (iymaxcf < nymax_big) ? iymaxcf : nymax_big;
        izmaxcf = (izmaxcf < nzmax_big) ? izmaxcf : nzmax_big;
        for (ix=ixmincf;ix<=ixmaxcf;ix++) {
          for (iy=iymincf;iy<=iymaxcf;iy++) {
            for (iz=izmincf;iz<=izmaxcf;iz++) {
              if ( ix >= ixminrad && ix <= ixmaxrad &&
                   iy >= iyminrad && iy <= iymaxrad &&
                   iz >= izminrad && iz <= izmaxrad ) {
                r2 = (XGrid[ix]-RoSFCo[iat][1]) *
                     (XGrid[ix]-RoSFCo[iat][1]) +
                     (YGrid[iy]-RoSFCo[iat][2]) *
                     (YGrid[iy]-RoSFCo[iat][2]) +
                     (ZGrid[iz]-RoSFCo[iat][3]) *
                     (ZGrid[iz]-RoSFCo[iat][3]);
                if ( FrGridMat[ix][iy][iz] != 'o' &&
                     GridMat[ix][iy][iz] != 'o' &&
                     r2 > FrRad2[iat] && r2 <= FrRadOut2[iat] ) {
                  r4 = r2 * r2;
                  SelfVol[iat] -= UnitVol / r4;
		              if (EmpCorrB[0]=='y')
		                SelfVol_corrB[iat] -= UnitVol / (r4*sqrt(r2));
                  //std::cout << "may be some problem with atom iat =" << iat << std::endl; // clangini debug
                }
                else if ( (FrGridMat[ix][iy][iz] == 'o' ||
                           GridMat[ix][iy][iz] == 'o') &&
                           r2 > FrRadOut2[iat] ) {
                  r4 = r2 * r2;
                  SelfVol[iat] += UnitVol / r4;
		              if (EmpCorrB[0]=='y')
		                SelfVol_corrB[iat] += UnitVol / (r4*sqrt(r2));
                }
              }
              else if ( (ix >= nxminFr && ix <= nxmaxFr+1 &&
                         iy >= nyminFr && iy <= nymaxFr+1 &&
                         iz >= nzminFr && iz <= nzmaxFr+1 &&
                         FrGridMat[ix][iy][iz] == 'o') ||
                         GridMat[ix][iy][iz] == 'o' ) {
                r2 = (XGrid[ix]-RoSFCo[iat][1]) *
                     (XGrid[ix]-RoSFCo[iat][1]) +
                     (YGrid[iy]-RoSFCo[iat][2]) *
                     (YGrid[iy]-RoSFCo[iat][2]) +
                     (ZGrid[iz]-RoSFCo[iat][3]) *
                     (ZGrid[iz]-RoSFCo[iat][3]);
                if ( r2 > FrRadOut2[iat] && r2 < cutoff1sq) {
                  r4 = r2 * r2;
                  SelfVol[iat] += UnitVol / r4;
		              if (EmpCorrB[0]=='y')
		                SelfVol_corrB[iat] += UnitVol / (r4*sqrt(r2));
                }
              }
            }
          }
        }
      }
    }
/* Integration with grid size 3*GrSiSo */
    cutoff2sq = cutoff2 * cutoff2;
    boxL = (cutoff2 + 0.00001) / GrSiSo + 1;
    GrSiSo3 = GrSiSo * 3.;
    UnitVol27 = UnitVol * 27.;
    for (iat=1;iat<=FrAtNu;iat++) {
      if (FrPaCh[iat] != 0. ) {
        ixc = (RoSFCo[iat][1] - Min.x) / GrSiSo3 + 1;
        iyc = (RoSFCo[iat][2] - Min.y) / GrSiSo3 + 1;
        izc = (RoSFCo[iat][3] - Min.z) / GrSiSo3 + 1;
        ixc *= 3;
        ixc -= 1;
        iyc *= 3;
        iyc -= 1;
        izc *= 3;
        izc -= 1;
        ixmincf = ixc-boxL;
        iymincf = iyc-boxL;
        izmincf = izc-boxL;
        ixmaxcf = ixc+boxL;
        iymaxcf = iyc+boxL;
        izmaxcf = izc+boxL;
        ixmincf = (ixmincf > nxmin_big) ? ixmincf : nxmin_big;
        iymincf = (iymincf > nymin_big) ? iymincf : nymin_big;
        izmincf = (izmincf > nzmin_big) ? izmincf : nzmin_big;
        ixmaxcf = (ixmaxcf < nxmax_big) ? ixmaxcf : nxmax_big;
        iymaxcf = (iymaxcf < nymax_big) ? iymaxcf : nymax_big;
        izmaxcf = (izmaxcf < nzmax_big) ? izmaxcf : nzmax_big;
        for (ix=ixmincf;ix<=ixmaxcf;ix+=3) {
          for (iy=iymincf;iy<=iymaxcf;iy+=3) {
            for (iz=izmincf;iz<=izmaxcf;iz+=3) {
              if ( (ix >= nxminFr && ix <= nxmaxFr+1 &&
                    iy >= nyminFr && iy <= nymaxFr+1 &&
                    iz >= nzminFr && iz <= nzmaxFr+1 &&
                    FrGridMat[ix][iy][iz] == 'o') ||
                    GridMat[ix][iy][iz] == 'o' ) {
                r2 = (XGrid[ix]-RoSFCo[iat][1]) *
                     (XGrid[ix]-RoSFCo[iat][1]) +
                     (YGrid[iy]-RoSFCo[iat][2]) *
                     (YGrid[iy]-RoSFCo[iat][2]) +
                     (ZGrid[iz]-RoSFCo[iat][3]) *
                     (ZGrid[iz]-RoSFCo[iat][3]);
                if ( r2 > cutoff1sq && r2 < cutoff2sq) {
                  r4 = r2 * r2;
                  SelfVol[iat] += UnitVol27 / r4;
		  if (EmpCorrB[0]=='y')
		    SelfVol_corrB[iat] += UnitVol27 / (r4*sqrt(r2));
                }
              }
            }
          }
        }
      }
    }
/* Integration with grid size 5*GrSiSo */
    UnitVol125 = UnitVol * 125.;
    for (ix=3;ix<=NGridx;ix+=5)
      for (iy=3;iy<=NGridy;iy+=5)
        for (iz=3;iz<=NGridz;iz+=5)
          if ( (ix >= nxminFr && ix <= nxmaxFr+1 &&
                iy >= nyminFr && iy <= nymaxFr+1 &&
                iz >= nzminFr && iz <= nzmaxFr+1 &&
                FrGridMat[ix][iy][iz] == 'o') ||
                GridMat[ix][iy][iz] == 'o' )
            for (iat=1;iat<=FrAtNu;iat++)
              if (FrPaCh[iat] != 0. ) {
                r2 = (XGrid[ix]-RoSFCo[iat][1]) *
                     (XGrid[ix]-RoSFCo[iat][1]) +
                     (YGrid[iy]-RoSFCo[iat][2]) *
                     (YGrid[iy]-RoSFCo[iat][2]) +
                     (ZGrid[iz]-RoSFCo[iat][3]) *
                     (ZGrid[iz]-RoSFCo[iat][3]);
                if ( r2 >= cutoff2sq) {
                  r4 = r2 * r2;
                  SelfVol[iat] += UnitVol125 / r4;
		  if (EmpCorrB[0]=='y')
		    SelfVol_corrB[iat] += UnitVol125 / (r4*sqrt(r2));
                }
              }
  }
  else {
    // clangini debug start
    // std::cout << "fragment partially out or rec elec grid box" << std::endl;
    //clangini debug end
/* The fragment is partially out of the rec elec grid box --> you need to check
   carefully the boundaries in order not to go out of the box */
    cutoff1sq = cutoff1 * cutoff1;
    boxL = (cutoff1 + 0.00001) / GrSiSo + 1;
/* Integration with grid size GrSiSo */
    for (iat=1;iat<=FrAtNu;iat++) {
      if (FrPaCh[iat] != 0. ) {
        ixc = (RoSFCo[iat][1] - Min.x) / GrSiSo + 1;
        iyc = (RoSFCo[iat][2] - Min.y) / GrSiSo + 1;
        izc = (RoSFCo[iat][3] - Min.z) / GrSiSo + 1;
        ixmincf = ixc-boxL;
        iymincf = iyc-boxL;
        izmincf = izc-boxL;
        ixmaxcf = ixc+boxL;
        iymaxcf = iyc+boxL;
        izmaxcf = izc+boxL;
        ixminrad = ixc-FrRadOut[iat];
        iyminrad = iyc-FrRadOut[iat];
        izminrad = izc-FrRadOut[iat];
        ixmaxrad = ixc+FrRadOut[iat];
        iymaxrad = iyc+FrRadOut[iat];
        izmaxrad = izc+FrRadOut[iat];
        ixmincf = (ixmincf > nxmin_big) ? ixmincf : nxmin_big;
        iymincf = (iymincf > nymin_big) ? iymincf : nymin_big;
        izmincf = (izmincf > nzmin_big) ? izmincf : nzmin_big;
        ixmaxcf = (ixmaxcf < nxmax_big) ? ixmaxcf : nxmax_big;
        iymaxcf = (iymaxcf < nymax_big) ? iymaxcf : nymax_big;
        izmaxcf = (izmaxcf < nzmax_big) ? izmaxcf : nzmax_big;
        for (ix=ixmincf;ix<=ixmaxcf;ix++) {
          for (iy=iymincf;iy<=iymaxcf;iy++) {
            for (iz=izmincf;iz<=izmaxcf;iz++) {
              if ( ix >= ixminrad && ix <= ixmaxrad &&
                   iy >= iyminrad && iy <= iymaxrad &&
                   iz >= izminrad && iz <= izmaxrad ) {
                r2 = (XGrid[ix]-RoSFCo[iat][1]) *
                     (XGrid[ix]-RoSFCo[iat][1]) +
                     (YGrid[iy]-RoSFCo[iat][2]) *
                     (YGrid[iy]-RoSFCo[iat][2]) +
                     (ZGrid[iz]-RoSFCo[iat][3]) *
                     (ZGrid[iz]-RoSFCo[iat][3]);
                if ( FrGridMat[ix][iy][iz] != 'o' &&
                     GridMat[ix][iy][iz] != 'o' &&
                     r2 > FrRad2[iat] && r2 < FrRadOut2[iat] ) {
                  r4 = r2 * r2;
                  SelfVol[iat] -= UnitVol / r4;
		  if (EmpCorrB[0]=='y')
		    SelfVol_corrB[iat] -= UnitVol / (r4*sqrt(r2));
                }
                else if ( (FrGridMat[ix][iy][iz] == 'o' ||
                           GridMat[ix][iy][iz] == 'o') &&
                           r2 > FrRadOut2[iat] ) {
                  r4 = r2 * r2;
                  SelfVol[iat] += UnitVol / r4;
		  if (EmpCorrB[0]=='y')
		    SelfVol_corrB[iat] += UnitVol / (r4*sqrt(r2));
                }
              }
              else if ( (ix >= nxminFr && ix <= nxmaxFr+1 &&
                         iy >= nyminFr && iy <= nymaxFr+1 &&
                         iz >= nzminFr && iz <= nzmaxFr+1 &&
                         FrGridMat[ix][iy][iz] == 'o') ||
                        (ix >= 1 && ix <= NGridx+1 &&
                         iy >= 1 && iy <= NGridy+1 &&
                         iz >= 1 && iz <= NGridz+1 &&
                         GridMat[ix][iy][iz] == 'o') ) {
                r2 = (XGrid[ix]-RoSFCo[iat][1]) *
                     (XGrid[ix]-RoSFCo[iat][1]) +
                     (YGrid[iy]-RoSFCo[iat][2]) *
                     (YGrid[iy]-RoSFCo[iat][2]) +
                     (ZGrid[iz]-RoSFCo[iat][3]) *
                     (ZGrid[iz]-RoSFCo[iat][3]);
                if ( r2 > FrRadOut2[iat] && r2 < cutoff1sq) {
                  r4 = r2 * r2;
                  SelfVol[iat] += UnitVol / r4;
		  if (EmpCorrB[0]=='y')
		    SelfVol_corrB[iat] += UnitVol / (r4*sqrt(r2));
                }
              }
            }
          }
        }
      }
    }
/* Integration with grid size 3*GrSiSo */
    cutoff2sq = cutoff2 * cutoff2;
    boxL = (cutoff2 + 0.00001) / GrSiSo + 1;
    GrSiSo3 = GrSiSo * 3.;
    UnitVol27 = UnitVol * 27.;
    for (iat=1;iat<=FrAtNu;iat++) {
      if (FrPaCh[iat] != 0. ) {
        ixc = (RoSFCo[iat][1] - Min.x) / GrSiSo3 + 1;
        iyc = (RoSFCo[iat][2] - Min.y) / GrSiSo3 + 1;
        izc = (RoSFCo[iat][3] - Min.z) / GrSiSo3 + 1;
        ixc *= 3;
        ixc -= 1;
        iyc *= 3;
        iyc -= 1;
        izc *= 3;
        izc -= 1;
        ixmincf = ixc-boxL;
        iymincf = iyc-boxL;
        izmincf = izc-boxL;
        ixmaxcf = ixc+boxL;
        iymaxcf = iyc+boxL;
        izmaxcf = izc+boxL;
        ixmincf = (ixmincf > nxmin_big) ? ixmincf : nxmin_big;
        iymincf = (iymincf > nymin_big) ? iymincf : nymin_big;
        izmincf = (izmincf > nzmin_big) ? izmincf : nzmin_big;
        ixmaxcf = (ixmaxcf < nxmax_big) ? ixmaxcf : nxmax_big;
        iymaxcf = (iymaxcf < nymax_big) ? iymaxcf : nymax_big;
        izmaxcf = (izmaxcf < nzmax_big) ? izmaxcf : nzmax_big;
        for (ix=ixmincf;ix<=ixmaxcf;ix+=3) {
          for (iy=iymincf;iy<=iymaxcf;iy+=3) {
            for (iz=izmincf;iz<=izmaxcf;iz+=3) {
              if ( (ix >= nxminFr && ix <= nxmaxFr+1 &&
                    iy >= nyminFr && iy <= nymaxFr+1 &&
                    iz >= nzminFr && iz <= nzmaxFr+1 &&
                    FrGridMat[ix][iy][iz] == 'o') ||
                   (ix >= 1 && ix <= NGridx+1 &&
                    iy >= 1 && iy <= NGridy+1 &&
                    iz >= 1 && iz <= NGridz+1 &&
                    GridMat[ix][iy][iz] == 'o') ) {
                r2 = (XGrid[ix]-RoSFCo[iat][1]) *
                     (XGrid[ix]-RoSFCo[iat][1]) +
                     (YGrid[iy]-RoSFCo[iat][2]) *
                     (YGrid[iy]-RoSFCo[iat][2]) +
                     (ZGrid[iz]-RoSFCo[iat][3]) *
                     (ZGrid[iz]-RoSFCo[iat][3]);
                if ( r2 > cutoff1sq && r2 < cutoff2sq) {
                  r4 = r2 * r2;
                  SelfVol[iat] += UnitVol27 / r4;
		  if (EmpCorrB[0]=='y')
		    SelfVol_corrB[iat] += UnitVol27 / (r4*sqrt(r2));
                }
              }
            }
          }
        }
      }
    }
/* Integration with grid size 5*GrSiSo */
    UnitVol125 = UnitVol * 125.;
    for (ix=3;ix<=NGridx;ix+=5)
      for (iy=3;iy<=NGridy;iy+=5)
        for (iz=3;iz<=NGridz;iz+=5)
          if ( (ix >= nxminFr && ix <= nxmaxFr+1 &&
                iy >= nyminFr && iy <= nymaxFr+1 &&
                iz >= nzminFr && iz <= nzmaxFr+1 &&
                FrGridMat[ix][iy][iz] == 'o') ||
               (ix >= 1 && ix <= NGridx+1 &&
                iy >= 1 && iy <= NGridy+1 &&
                iz >= 1 && iz <= NGridz+1 &&
                GridMat[ix][iy][iz] == 'o') )
            for (iat=1;iat<=FrAtNu;iat++)
              if (FrPaCh[iat] != 0. ) {
                r2 = (XGrid[ix]-RoSFCo[iat][1]) *
                     (XGrid[ix]-RoSFCo[iat][1]) +
                     (YGrid[iy]-RoSFCo[iat][2]) *
                     (YGrid[iy]-RoSFCo[iat][2]) +
                     (ZGrid[iz]-RoSFCo[iat][3]) *
                     (ZGrid[iz]-RoSFCo[iat][3]);
                if ( r2 >= cutoff2sq) {
                  r4 = r2 * r2;
                  SelfVol[iat] += UnitVol125 / r4;
		  if (EmpCorrB[0]=='y')
		    SelfVol_corrB[iat] += UnitVol125 / (r4*sqrt(r2));
                }
              }
  }

  if (ix == FrAtNu+1 )
    return 1;
  else
    return 0;
}

int screened_int(double **RePaCh_Fr,double *ReEffRad,
                 int NNeigh3,int *NeighList3,int FrAtNu,
                 double *FrPaCh,double *FrEffRad,double **dist2,double **dist,
                 double Kelec,double Ksolv,double *PReFrIntElec)
/*##########################################
Calculate the frag-rec screened interaction energy
###########################################*/

/*##########################################
double *RePaCh_Fr -------- Modified rec partial charges (for the charged residues
                          around the BS a unit charge is assigned to the atom
                          closest to the charge center
double *ReEffRad -------- ReEffRad[n] = effective radius of rec atom n
int NNeigh3 ------------- Amount of rec atoms falling at least once
                          in the cutoff for non-bonded interactions
int *NeighList3 --------- NeighList3[1->NNeigh3] = rec atom # falling at least
                          once in the cutoff for non-bonded interactions
int FrAtNu -------------- Tot # frag atoms
double *FrPaCh ----------- Frag partial charges
double *FrEffRad -------- FrEffRad[n] = effective radius of frag atom n
double **dist2 ----------- Squared interatomic rec-frag distances
double **dist ------------ Frag-rec interatomic distances
double Kelec ------------ Constant
double Ksolv ------------ Constant
double *PReFrIntElec ---- Rec-Frag screened interaction
###########################################*/
{
  int iat,jat;
  double Rij,Inte;

  *PReFrIntElec = 0.;
  for (iat=1;iat<=NNeigh3;iat++) {
    for (jat=1;jat<=FrAtNu;jat++) {
      if (FrPaCh[jat] != 0. ) {
        if (dist2[jat][NeighList3[iat]] > 0.) {


          Rij = (double) ReEffRad[NeighList3[iat]] * FrEffRad[jat];
          Inte = RePaCh_Fr[jat][NeighList3[iat]]*FrPaCh[jat] *
                 (Kelec / dist[jat][NeighList3[iat]] +
                 Ksolv / sqrtf (dist2[jat][NeighList3[iat]] +
                 Rij * expf(-dist2[jat][NeighList3[iat]]/(4.*Rij))));
          *PReFrIntElec += Inte;
        }
      }
    }
  }

  if (iat == NNeigh3+1 )
    return 1;
  else
    return 0;
}

int screened_int_forces(double **RePaCh_Fr, double *ReEffRad,
                        int NNeigh3, int *NeighList3, int FrAtNu,
                        double *FrPaCh, double *FrEffRad, double **dist2, double **dist,
                        double Kelec, double Ksolv,
                        double **RoSFCo, double **ReCoor, double **RelCOMCo,
                        double *F_elec, double *T_elec, double corr_scrint)
/*##########################################
Calculate the forces derived from the 
frag-rec screened interaction energy
###########################################*/

/*##########################################
double *RePaCh_Fr -------- Modified rec partial charges (for the charged residues
                          around the BS a unit charge is assigned to the atom
                          closest to the charge center
double *ReEffRad -------- ReEffRad[n] = effective radius of rec atom n
int NNeigh3 ------------- Amount of rec atoms falling at least once
                          in the cutoff for non-bonded interactions
int *NeighList3 --------- NeighList3[1->NNeigh3] = rec atom # falling at least
                          once in the cutoff for non-bonded interactions
int FrAtNu -------------- Tot # frag atoms
double *FrPaCh ----------- Frag partial charges
double *FrEffRad -------- FrEffRad[n] = effective radius of frag atom n
double **dist2 ----------- Squared interatomic rec-frag distances
double **dist ------------ Frag-rec interatomic distances
double Kelec ------------ Constant
double Ksolv ------------ Constant
double *PReFrIntElec ---- Rec-Frag screened interaction
###########################################*/
{
  int iat, jat;
  double Rij, Rij_GB;
  double e_ij[4];
  double F_i[4];
  double T_i[4];
  double dEdr;
  // double En_i;

  F_elec[1] = 0.0;
  F_elec[2] = 0.0;
  F_elec[3] = 0.0;
  T_elec[1] = 0.0;
  T_elec[2] = 0.0;
  T_elec[3] = 0.0;

  //*PIntEn = 0.;
  for (jat = 1; jat <= FrAtNu; jat++) // loop over frag atoms
  {
    F_i[1] = 0.0;
    F_i[2] = 0.0;
    F_i[3] = 0.0;

    if (FrPaCh[jat] != 0.)
    {
      for (iat = 1; iat <= NNeigh3; iat++) // loop over rec atoms
      {
        dEdr = 0.0;
        if (dist2[jat][NeighList3[iat]] > 0.)
        {

          Rij = (double)ReEffRad[NeighList3[iat]] * FrEffRad[jat];
          Rij_GB = sqrtf(dist2[jat][NeighList3[iat]] +
                         Rij * expf(-dist2[jat][NeighList3[iat]] / (4. * Rij)));

          // En_i = RePaCh_Fr[jat][NeighList3[iat]] * FrPaCh[jat] *
          //       (Kelec / dist[jat][NeighList3[iat]] +
          //         Ksolv / Rij_GB);
          // *PIntEn += En_i;
          // dEdr = -RePaCh_Fr[jat][NeighList3[iat]] * FrPaCh[jat] * (Kelec / dist2[jat][NeighList3[iat]]) +
          //        RePaCh_Fr[jat][NeighList3[iat]] * FrPaCh[jat] * 0.5 * Ksolv / (Rij_GB * Rij_GB * Rij_GB) *
          //            (2 * dist[jat][NeighList3[iat]] - 0.5 * dist[jat][NeighList3[iat]] * 
          //            expf(-dist2[jat][NeighList3[iat]] / (4. * Rij)));
          dEdr = -RePaCh_Fr[jat][NeighList3[iat]] * FrPaCh[jat] * ((Kelec / (dist2[jat][NeighList3[iat]] * dist[jat][NeighList3[iat]])) +
                  Ksolv / (Rij_GB * Rij_GB * Rij_GB) *
                     (1. - 0.25 * expf(-dist2[jat][NeighList3[iat]] / (4. * Rij))));
          e_ij[1] = (ReCoor[NeighList3[iat]][1] - RoSFCo[jat][1]); // / dist[jat][NeighList3[iat]];
          e_ij[2] = (ReCoor[NeighList3[iat]][2] - RoSFCo[jat][2]); // / dist[jat][NeighList3[iat]];
          e_ij[3] = (ReCoor[NeighList3[iat]][3] - RoSFCo[jat][3]); // / dist[jat][NeighList3[iat]];

          F_i[1] += dEdr * e_ij[1];
          F_i[2] += dEdr * e_ij[2];
          F_i[3] += dEdr * e_ij[3];
          // *PReFrIntElec += Inte;
        }
      }

      F_i[1] *= corr_scrint;
      F_i[2] *= corr_scrint;
      F_i[3] *= corr_scrint;

      F_elec[1] += F_i[1];
      F_elec[2] += F_i[2];
      F_elec[3] += F_i[3];

      VectPr(RelCOMCo[jat][1], RelCOMCo[jat][2], RelCOMCo[jat][3],
             F_i[1], F_i[2], F_i[3],
             &T_i[1], &T_i[2], &T_i[3]);
      T_elec[1] += T_i[1];
      T_elec[2] += T_i[2];
      T_elec[3] += T_i[3];
    }
  }

  if (iat == NNeigh3 + 1)
    return 1;
  else
    return 0;
}

void check_gradient_int_elec(int FrAtNu, int ReAtNu, double *ReVdWE_sr, double *FrVdWE_sr,
                             double *ReVdWR, double *FrVdWR,
                             double *Felec, double *Telec,
                             double **RoSFCo, double **ReCoor,
                             double *ReMinC,
                             double GrSiCu_en, int *CubNum_en, int ***CubFAI_en, int ***CubLAI_en,
                             int *CubLiA_en, int PsSpNC, int ***PsSphe,
                             double PsSpRa, int ReReNu, int *AtReprRes,
                             int *FiAtRes, int *LaAtRes, int *FrAtEl_nu, double *AtWei,
                             double *RePaCh, double *FrPaCh, double *TotChaRes, int NuChResEn, int *LiChResEn,
                             double **ChFrRe_ps_elec, double *ReEffRad, double *FrEffRad,
                             int *NeighList3, int NNeigh3, double Kelec, double Ksolv, double corr_scrint)
{
  /* This function checks the gradients of int_elec */
  int i, j, k;
  int iat, jat;
  int areturn;
  double **dist2, **dist, **dummy;
  double num_grad[6]; // numerical gradient
  double eps = 0.00001;
  double eps_rot = eps * 0.0174533;
  double **eps_coords;
  double E_plus, E_minus;
  double COM[4];
  Quaternion<double> q_rb;
  double **ChFrRe_tmp;

  eps_coords = zero_dmatrix(1, FrAtNu, 1, 3);
  copy_dmatrix(RoSFCo, eps_coords, 1, FrAtNu, 1, 3);
  dist2 = zero_dmatrix(1, FrAtNu, 1, ReAtNu);
  dist = zero_dmatrix(1, FrAtNu,  1, ReAtNu);
  dummy = zero_dmatrix(1,FrAtNu, 1, ReAtNu);
  ChFrRe_tmp = dmatrix(1, FrAtNu, 1, ReAtNu);
  // copy_dmatrix(ChFrRe_ps_elec 1, FrAtNu, 1, ReAtNu);

  // numerical forces:
  for (j = 1; j <= 3; j++)
  {
    // x + eps
    for (i = 1; i <= FrAtNu; i++)
    {
      eps_coords[i][j] += eps;
    }
    SqDisFrRe_ps(FrAtNu, eps_coords, ReCoor, ReMinC, GrSiCu_en,
                 CubNum_en, CubFAI_en, CubLAI_en, CubLiA_en,
                 PsSpNC, PsSphe, dummy, ReAtNu, PsSpRa,
                 RePaCh, ReReNu, AtReprRes, FiAtRes, LaAtRes,
                 TotChaRes, NuChResEn, LiChResEn,
                 dist2, ChFrRe_tmp);
    dist2_to_dist(dist2, dist, FrAtNu, ReAtNu);
    // for (iat = 1; iat <= FrAtNu; iat++)
    // {
    //   for (jat = 1; jat <= ReAtNu; jat++)
    //   {
    //     if ((distortion[iat][jat] < 0. && dist2[iat][jat] >= 0.) || 
    //         (distortion[iat][jat] > 0. && dist2[iat][jat] <= 0.)){
    //           std::cerr << "PROBLEM WITH DISTANCES" << std::endl;
    //         }
    //   }
    // }
    // for (iat = 1; iat <= FrAtNu; iat++)
    // {
    //   for (jat = 1; jat <= ReAtNu; jat++)
    //   {
    //     if (ChFrRe_tmp[iat][jat] != ChFrRe_ps_elec[iat][jat])
    //       std::cerr << "PROBLEM WITH NUMERICAL GRADIENT" << std::endl;
    //   }
    // }
    areturn = screened_int(ChFrRe_ps_elec, ReEffRad, NNeigh3, NeighList3, FrAtNu, FrPaCh,
                           FrEffRad, dist2, dist, Kelec, Ksolv, &E_plus);
    // E_plus *= corr_scrint;
    // copy_dmatrix(RoSFCo, eps_coords, 1, FrAtNu, 1, 3);
    // x - eps
    for (i = 1; i <= FrAtNu; i++)
    {
      eps_coords[i][j] -= 2 * eps;
    }
    SqDisFrRe_ps(FrAtNu, eps_coords, ReCoor, ReMinC, GrSiCu_en,
                 CubNum_en, CubFAI_en, CubLAI_en, CubLiA_en,
                 PsSpNC, PsSphe, dummy, ReAtNu, PsSpRa,
                 RePaCh, ReReNu, AtReprRes, FiAtRes, LaAtRes,
                 TotChaRes, NuChResEn, LiChResEn,
                 dist2, ChFrRe_tmp);
    dist2_to_dist(dist2, dist, FrAtNu, ReAtNu);
    // for (iat = 1; iat <= FrAtNu; iat++)
    // {
    //   for (jat = 1; jat <= ReAtNu; jat++)
    //   {
    //     if ((distortion[iat][jat] < 0. && dist2[iat][jat] >= 0.) ||
    //         (distortion[iat][jat] > 0. && dist2[iat][jat] <= 0.))
    //     {
    //       std::cerr << "PROBLEM WITH DISTANCES" << std::endl;
    //     }
    //   }
    // }
    // for (iat = 1; iat <= FrAtNu; iat++){
    //   for (jat = 1; jat <= ReAtNu; jat++){
    //     if (ChFrRe_tmp[iat][jat] != ChFrRe_ps_elec[iat][jat])
    //       std::cerr << "PROBLEM WITH NUMERICALS" << std::endl;
    //   }
    // }
    areturn = screened_int(ChFrRe_ps_elec, ReEffRad, NNeigh3, NeighList3, FrAtNu, FrPaCh,
                           FrEffRad, dist2, dist, Kelec, Ksolv, &E_minus);
    copy_dmatrix(RoSFCo, eps_coords, 1, FrAtNu, 1, 3);
    // numerical gradient:
    num_grad[j] = (E_plus - E_minus) / (2 * eps);
  }
  std::cout << "Grad check" << std::endl;
  std::cout << -Felec[1] << " " << num_grad[1] * corr_scrint << std::endl;
  std::cout << -Felec[2] << " " << num_grad[2] * corr_scrint << std::endl;
  std::cout << -Felec[3] << " " << num_grad[3] * corr_scrint << std::endl;
  //numerical torques:

  while (k <= 3)
  {
    E_plus = 0.0;
    E_minus = 0.0;
    CenterOfMass(COM, RoSFCo, FrAtNu, AtWei, FrAtEl_nu);
    if (k == 1)
    {
      q_rb.fromXYZrot(eps_rot, 0.0, 0.0);
    }
    else if (k == 2)
    {
      q_rb.fromXYZrot(0.0, eps_rot, 0.0);
    }
    else if (k == 3)
    {
      q_rb.fromXYZrot(0.0, 0.0, eps_rot);
    }
    for (i = 1; i <= FrAtNu; i++)
    {
      q_rb.quatConjugateVecRef(eps_coords[i], COM[1], COM[2], COM[3]);
    }
    SqDisFrRe_ps(FrAtNu, eps_coords, ReCoor, ReMinC, GrSiCu_en,
                 CubNum_en, CubFAI_en, CubLAI_en, CubLiA_en,
                 PsSpNC, PsSphe, dummy, ReAtNu, PsSpRa,
                 RePaCh, ReReNu, AtReprRes, FiAtRes, LaAtRes,
                 TotChaRes, NuChResEn, LiChResEn,
                 dist2, ChFrRe_tmp);
    dist2_to_dist(dist2, dist, FrAtNu, ReAtNu);
    areturn = screened_int(ChFrRe_ps_elec, ReEffRad, NNeigh3, NeighList3, FrAtNu, FrPaCh,
                           FrEffRad, dist2, dist, Kelec, Ksolv, &E_plus);
    if (k == 1)
    {
      q_rb.fromXYZrot(-2 * eps_rot, 0.0, 0.0);
    }
    else if (k == 2)
    {
      q_rb.fromXYZrot(0.0, -2 * eps_rot, 0.0);
    }
    else if (k == 3)
    {
      q_rb.fromXYZrot(0.0, 0.0, -2 * eps_rot);
    }
    for (i = 1; i <= FrAtNu; i++)
    {
      q_rb.quatConjugateVecRef(eps_coords[i], COM[1], COM[2], COM[3]);
    }
    SqDisFrRe_ps(FrAtNu, eps_coords, ReCoor, ReMinC, GrSiCu_en,
                 CubNum_en, CubFAI_en, CubLAI_en, CubLiA_en,
                 PsSpNC, PsSphe, dummy, ReAtNu, PsSpRa,
                 RePaCh, ReReNu, AtReprRes, FiAtRes, LaAtRes,
                 TotChaRes, NuChResEn, LiChResEn,
                 dist2, ChFrRe_tmp);
    dist2_to_dist(dist2, dist, FrAtNu, ReAtNu);
    areturn = screened_int(ChFrRe_ps_elec, ReEffRad, NNeigh3, NeighList3, FrAtNu, FrPaCh,
                           FrEffRad, dist2, dist, Kelec, Ksolv, &E_minus);
    copy_dmatrix(RoSFCo, eps_coords, 1, FrAtNu, 1, 3);
    // numerical gradient:
    num_grad[k + 3] = (E_plus - E_minus) / (2 * eps_rot);
    k++;
  }
  std::cout << -Telec[1] << " " << num_grad[4] * corr_scrint << std::endl;
  std::cout << -Telec[2] << " " << num_grad[5] * corr_scrint << std::endl;
  std::cout << -Telec[3] << " " << num_grad[6] * corr_scrint << std::endl;

  free_dmatrix(eps_coords, 1, FrAtNu, 1, 3);
  free_dmatrix(dist2, 1, FrAtNu, 1, ReAtNu);
  free_dmatrix(dist, 1, FrAtNu, 1, ReAtNu);
  free_dmatrix(dummy, 1, FrAtNu, 1, ReAtNu);
  free_dmatrix(ChFrRe_tmp, 1, FrAtNu, 1, ReAtNu);
  return;
}

int GB_int_fr(int FrAtNu,double **Frdist2,double *FrPaCh,
              double *EffRad,double Ksolv,double *PIntEnTot)
/*##########################################
Calculate the frag intramolecular interaction energy
###########################################*/

/*##########################################
int FrAtNu -------------- Tot # frag atoms
double **Frdist2 --------- Squared interatomic frag distances
double *FrPaCh ----------- Frag partial charges
double *EffRad ---------- EffRad[n] = effective radius of frag atom n
double Ksolv ------------ Constant
double *PFrIntEn -------- Tot frag intramolecular interaction energy
###########################################*/
{
  int iat,jat;
  double Rij,Chiat,Inte;

  *PIntEnTot = 0.;
  for (iat=1;iat<=FrAtNu;iat++) {
    if (FrPaCh[iat] != 0. ) {
      Chiat = Ksolv * FrPaCh[iat];
      for (jat=iat+1;jat<=FrAtNu;jat++) {
        if (FrPaCh[jat] != 0. ) {  /* MODIFICATION 13/11/99 */
          Rij = EffRad[iat] * EffRad[jat];

          Inte = Chiat*FrPaCh[jat] /
            sqrtf (Frdist2[iat][jat] + Rij * exp(-Frdist2[iat][jat]/(4.*Rij)));
          *PIntEnTot += Inte;
        }
      }
    }
  }

  if (iat == FrAtNu+1 )
    return 1;
  else
    return 0;
}

int GB_int_re(int FrAtNu,double **ReCoor,double *FrPaCh,
              double *EffRad,double Ksolv,double *PIntEnTot)
/*##########################################
Calculate the rec intramolecular interaction energy (in the presence of the frag)
###########################################*/

/*##########################################
int FrAtNu -------------- Tot # rec atoms
double **ReCoor ---------- Rec Coordinates
double *FrPaCh ----------- Rec partial charges
double *EffRad ---------- EffRad[n] = effective radius of rec atom n
double Ksolv ------------ Constant
double *PFrIntEn -------- Tot rec intramolecular interaction energy
###########################################*/
{
  int iat,jat;
  double Rij,Chiat,Inte,r2;

  *PIntEnTot = 0.;
  for (iat=1;iat<=FrAtNu;iat++) {
    if (FrPaCh[iat] != 0. ) {
      Chiat = Ksolv * FrPaCh[iat];
      for (jat=iat+1;jat<=FrAtNu;jat++) {
        if (FrPaCh[jat] != 0. ) {  /* MODIFICATION 13/11/99 */
          r2 = (ReCoor[iat][1]-ReCoor[jat][1])*(ReCoor[iat][1]-ReCoor[jat][1]) +
               (ReCoor[iat][2]-ReCoor[jat][2])*(ReCoor[iat][2]-ReCoor[jat][2]) +
               (ReCoor[iat][3]-ReCoor[jat][3])*(ReCoor[iat][3]-ReCoor[jat][3]);
          Rij = EffRad[iat] * EffRad[jat];

          Inte = Chiat*FrPaCh[jat] /
            sqrtf (r2 + Rij * exp(-r2/(4.*Rij)));
          *PIntEnTot += Inte;
        }
      }
    }
  }

  if (iat == FrAtNu+1 )
    return 1;
  else
    return 0;
}

int FragSolvEn(int FrAtNu,double **FrCoor,double *FrPaCh,
               double *FrVdWR,double *FrRadOut,
               double *FrRadOut2, double *FrEffRad_bound,
               double **Frdist2,int Nsurfpt_fr,
               struct point *surfpt_fr_orig,double WaMoRa,double GrSiSo,
               double Ksolv,double pi4,double *PFrSolvEn,char *EmpCorrB,FILE*FPaOut)
/*##########################################
Calculate the solvation energy of the isolated frag
according to the GB formula
###########################################*/

/*##########################################
int FrAtNu -------------- Tot # frag atoms
double **FrCoor ---------- Frag coordinates in the original location
double *FrPaCh ----------- Frag partial charges
double *FrVdWR ----------- Frag vdW radii
double *FrRadOut -------- Frag charge radii + WaMoRa
double *FrRadOut2 ------- (Frag charge radii + WaMoRa)^2
double **Frdist2 --------- Squared interatomic frag distances
int Nsurfpt_fr ---------- Tot # of points over the frag SAS1
struct point *surfpt_fr_orig - Coor of points over frag SAS1 (obtained from
                               FrCoor coordinates)
double WaMoRa ----------- Radius of the water molecule
double GrSiSo ----------- Size of the 3D grid used for cont. electrostatics
double Ksolv ------------ Constant
double pi4 -------------- 4 * greekpi
double *PFrSolvEn ------- Frag solvation energy
###########################################*/
{
  int iat,ix,iy,iz,nn,NGridx,NGridy,NGridz,NGrid;
  double *FrSelfVol,*FrEffRad,FrSelfEn,FrIntEn,UnitVol,*XGrid,*YGrid,*ZGrid,
         *FrSelfVol_corrB;
  struct point Min,Max;
  char ***FrGridMat;
/*##########################################
int iat,ix,iy,iz,nn ----- Multipurpose variables
int NGridx -------------- Tot # of frag grid points along x
int NGridy -------------- Tot # of frag grid points along y
int NGridz -------------- Tot # of frag grid points along z
double *FrSelfVol ------- FrSelfVol[iat] = integral of 1/r^4 over the frag
                          volume for atom iat
double *FrEffRad -------- FrEffRad[n] = effective radius of frag atom n
double FrSelfEn --------- Total self energy of the isolated frag
double FrIntEn ---------- Total intramolecular interaction energy
                          of the isolated frag
double UnitVol ---------- Volume of the grid element for cont. elec.
double *XGrid ----------- X coor of the grid points
double *YGrid ----------- Y coor of the grid points
double *ZGrid ----------- Z coor of the grid points
struct point Min -------- Min coor of the frag grid box
struct point Max -------- Max coor of the frag grid box
char ***FrGridMat ------- Matrix telling if a grid point is occupied by the
                          frag (o), empty (e), or if it belongs to the interface
                          between SAS and MS (s)
###########################################*/

  /* Get the # of grid pts needed to cover the frag molecule along the
     three axis (no grid increase) */
  nn = get_Grid_Dim(FrAtNu,FrCoor,FrVdWR,WaMoRa,GrSiSo,0.,&NGridx,&NGridy,
                    &NGridz,&NGrid,&Min,&Max,&UnitVol);

  XGrid=dvector(1,NGridx);
  YGrid=dvector(1,NGridy);
  ZGrid=dvector(1,NGridz);
  /* Get the cartesian coor for the grid points */
  nn = Coor_Grid_Pts(GrSiSo,NGridx,NGridy,NGridz,Min,XGrid,YGrid,ZGrid);

  FrSelfVol=dvector(1,FrAtNu);
  FrSelfVol_corrB=dvector(1,FrAtNu);
  FrEffRad=dvector(1,FrAtNu);
  FrGridMat = c3tensor(1,NGridx+1,1,NGridy+1,1,NGridz+1);
  for (ix=1;ix<=NGridx+1;ix++)
    for (iy=1;iy<=NGridy+1;iy++)
      for (iz=1;iz<=NGridz+1;iz++)
        FrGridMat[ix][iy][iz] = 'e';

/* Make the map (FrGridMat) of the 3D grid points occupied by the volume
   enclosed by the frag SAS  */
  nn = SAS_Volume(FrAtNu,FrCoor,FrRadOut,FrRadOut2,Min,GrSiSo,
                  1,1,1,NGridx,NGridy,NGridz,FrGridMat);
  for (iat=1;iat<=FrAtNu;iat++)
  {
    FrSelfVol[iat] = 0.;
    FrSelfVol_corrB[iat] = 0.;
  }
/* Place a sphere of radius WaMoRa on every SAS surface
   grid point (*surfpt_fr_orig) and mark as empty all the volume grid
   points falling inside the sphere */
  nn = Excl_Grid(FrAtNu,FrCoor,Min,FrRadOut,FrRadOut2,WaMoRa,GrSiSo,
                 1,1,1,NGridx,NGridy,NGridz,UnitVol,
                 FrGridMat,Nsurfpt_fr,surfpt_fr_orig,FrSelfVol,FrSelfVol_corrB,
		             EmpCorrB);
  // for (int jj=1;jj<=FrAtNu;jj++){
  //   std::cout << "FrSelfVol_corrB[" << jj << "]= " << FrSelfVol_corrB[jj] << '\n';
  //   std::cout << "FrSelfVol[" << jj << "]= " << FrSelfVol[jj] << '\n';
  // }
/* Calculate the frag self energy */
  nn = Get_Self_En_Fr(FrAtNu,FrCoor,FrPaCh,FrRadOut,FrRadOut2,FrEffRad_bound,
                      XGrid,YGrid,ZGrid,UnitVol,Ksolv,pi4,FrGridMat,
                      1,1,1,NGridx,NGridy,NGridz,FrSelfVol,FrEffRad,&FrSelfEn,
		                  FrSelfVol_corrB,EmpCorrB,FPaOut);
  
  for (iat=1;iat <= FrAtNu; iat++){ 
    // set lower bound on frag bond radius
    FrEffRad_bound[iat] = FrEffRad[iat];
  }
/* Calculate the frag interaction energy */
  nn = GB_int_fr(FrAtNu,Frdist2,FrPaCh,FrEffRad,Ksolv,&FrIntEn);

  *PFrSolvEn = FrSelfEn + FrIntEn;
/*  printf("%lf\n",*PFrSolvEn); */

/* Free memory */
  free_dvector(XGrid,1,NGridx);
  free_dvector(YGrid,1,NGridy);
  free_dvector(ZGrid,1,NGridz);
  free_dvector(FrEffRad,1,FrAtNu);
  free_dvector(FrSelfVol,1,FrAtNu);
  free_c3tensor(FrGridMat,1,NGridx+1,1,NGridy+1,1,NGridz+1);
  free_dvector(FrSelfVol_corrB,1,FrAtNu);

  if ( iat == FrAtNu+1 )
    return 1;
  else
    return 0;
}

int Get_Self_En_Fr(int FrAtNu,double **RoSFCo,double *FrPaCh,double *FrRadOut,
                   double *FrRadOut2,double *FrEffRad_bound,double *XGrid,double *YGrid,double *ZGrid,
                   double UnitVol,double Ksolv,double pi4,char ***FrGridMat,
                   int nxminFr,int nyminFr,int nzminFr,
                   int nxmaxFr,int nymaxFr,int nzmaxFr,
                   double *FrSelfVol,double *FrEffRad,double *PFrSelfEn,
		               double *FrSelfVol_corrB,char *EmpCorrB,FILE * FPaOut)
/*##########################################
Calculate the frag self energy
###########################################*/

/*##########################################
int FrAtNu -------------- Tot # frag atoms
double **RoSFCo ---------- Frag coordinates in the seeded conformation
double *FrPaCh ----------- Frag partial charges
double *FrRadOut -------- Frag charge radii + WaMoRa
double *FrRadOut2 ------- (Frag charge radii + WaMoRa)^2
double *XGrid ----------- X coor of the grid points
double *YGrid ----------- Y coor of the grid points
double *ZGrid ----------- Z coor of the grid points
double UnitVol ---------- Volume of the grid element for cont. elec.
double Ksolv ------------ Constant
double pi4 -------------- 4 * greekpi
char ***FrGridMat ------- Small submatrix of GridMat around the frag telling the
                          volume occupied by the frag in the bound conformation
int nxminFr ------------- grid point (along x) where the frag starts
int nyminFr ------------- grid point (along y) where the frag starts
int nzminFr ------------- grid point (along z) where the frag starts
int nxmaxFr ------------- grid point (along x) where the frag ends
int nymaxFr ------------- grid point (along y) where the frag ends
int nzmaxFr ------------- grid point (along z) where the frag ends
double *FrSelfVol ------- FrSelfVol[iat] = integral of 1/r^4 over the solute
                          volume for frag atom iat
double *FrEffRad -------- FrEffRad[n] = effective radius of frag atom n
double *PFrSelfEn ------- Tot frag self-energy
###########################################*/
{
  int ix,iy,iz,iat;
  double r2,r4;

  ix=nxminFr;

  *PFrSelfEn = 0.;
  //int jumppoint; //debug
  for (iat=1;iat<=FrAtNu;iat++) {
    //jumppoint = 0; //debug


    if (FrPaCh[iat] != 0. ) {
      for (ix=nxminFr;ix<=nxmaxFr;ix++) {
        for (iy=nyminFr;iy<=nymaxFr;iy++) {
          for (iz=nzminFr;iz<=nzmaxFr;iz++) {
            if ( FrGridMat[ix][iy][iz] == 'o' ) {
              r2 = (XGrid[ix]-RoSFCo[iat][1]) *
                   (XGrid[ix]-RoSFCo[iat][1]) +
                   (YGrid[iy]-RoSFCo[iat][2]) *
                   (YGrid[iy]-RoSFCo[iat][2]) +
                   (ZGrid[iz]-RoSFCo[iat][3]) *
                   (ZGrid[iz]-RoSFCo[iat][3]);
              if ( r2 > FrRadOut2[iat]) {
                r4 = r2 * r2;
                FrSelfVol[iat] += UnitVol / r4;
		            if (EmpCorrB[0]=='y')
		              FrSelfVol_corrB[iat] += UnitVol / (r4*sqrt(r2));
              }
            }
            /*else if (FrGridMat[ix][iy][iz] == 's') {
              r2 = (XGrid[ix]-RoSFCo[iat][1]) *
                   (XGrid[ix]-RoSFCo[iat][1]) +
                   (YGrid[iy]-RoSFCo[iat][2]) *
                   (YGrid[iy]-RoSFCo[iat][2]) +
                   (ZGrid[iz]-RoSFCo[iat][3]) *
                   (ZGrid[iz]-RoSFCo[iat][3]);
              if ( r2 <= FrRadOut2[iat]) {
                jumppoint++;
              }
            }FrSelfVol_corrB[ */ //debug
          }
        }
      }

      //std::cout << "FrSelfVol[" << iat << "]/pi4 = " << FrSelfVol[iat]/pi4 << "\n";
      //std::cout << "Calculated Born radius[" << iat << "] = " << 1. / ( 1./(FrRadOut[iat]) - FrSelfVol[iat]/pi4 ) << "\n";
      //std::cout << "My hypothesis Born radius[" << iat << "] = " << 1. / ( 1./(FrRadOut[iat]-3.5) + FrSelfVol[iat]/pi4 ) << "\n";
      //std::cout << "FrRadOut[" << iat << "] = " << FrRadOut[iat] << "\n" ;

      if (EmpCorrB[0]!='y')
        FrEffRad[iat] = 1. / ( 1./FrRadOut[iat] - FrSelfVol[iat]/pi4 );
      else
      {

    	  FrEffRad[iat] = 1./( (-1.*(1./FrRadOut[iat] - FrSelfVol[iat]/pi4))
    			       + 3.0*sqrt( (1./(2.*FrRadOut[iat]*FrRadOut[iat])) - (FrSelfVol_corrB[iat]/pi4) ) )
    	           + 0.215;

        // std::cout << "=====" << "\n";
        // std::cout << "1/2R^2 = " << 1./(2.*FrRadOut2[iat]) << " FrSelfVol_corrB[iat]/pi4 " << (FrSelfVol_corrB[iat]/pi4) << std::endl;
        // std::cout << "G0 = " << 1./FrRadOut[iat] - FrSelfVol[iat]/pi4 << std::endl;
        // std::cout << "G1 = " << 3.0*sqrt( (1./(2.*FrRadOut[iat]*FrRadOut[iat])) - (FrSelfVol_corrB[iat]/pi4) ) << "\n";
        // std::cout << "FrEffRad_corrB[" << iat << "] = " << FrEffRad[iat] << std::endl;
        // std::cout << "1/R = " << 1./FrRadOut[iat] << "  FrSelfVol[iat]/pi4 = " << FrSelfVol[iat]/pi4 << std::endl;
        // std::cout << "FrEffRad[" << iat << "] = " << 1. / ( 1./FrRadOut[iat] - FrSelfVol[iat]/pi4 ) << std::endl;
        // std::cout << "Lower bound (Born radius) = " << FrRadOut[iat] - 1.4 << std::endl;

    	  /*
    	    Dey exception handling :
    	    in rare cases the expression :
    	    (1./(2.*ReRadOut[iat]*ReRadOut[iat])) - ((*SelfVol_corrB)[iat]/pi4)
    	    can become < 0 -> the sqrt() function cannot be evaluated, which leads
    	    to "nan" values or the effective born radius is smaller than 0

    	  */
    	  if(FrEffRad[iat]<=0 || std::isnan(FrEffRad[iat]))
    	  {
    #ifndef NOWARN
    	    fprintf(FPaOut,"WARNING could not calculate empirically-corrected effective born radius of fragment atom %d, using standard approach\n",iat);
    #endif
          // std::cout << "Fragment effective radius is 0 or nan" << std::endl;
    	    FrEffRad[iat] = 1. / ( 1./FrRadOut[iat] - FrSelfVol[iat]/pi4 );
    	  }

          }

          *PFrSelfEn += Ksolv * FrPaCh[iat] * FrPaCh[iat] / (2. * FrEffRad[iat]);

    }
    //std::cout << "Jumped surf point for atom " << iat << " = " << jumppoint <<"\n";
  }

  if (ix == FrAtNu+1 )
    return 1;
  else
    return 0;
}
